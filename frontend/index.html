<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#121212">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="shortcut icon" href="favicon.ico" type="image/png" />
    <meta name="google-adsense-account" content="ca-pub-1074925740865557">
    <title>Musickêra</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Circular', 'Segoe UI', Arial, sans-serif;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            background: linear-gradient(180deg, #121212 0%, #1a1a1a 100%);
            color: #fff;
            min-height: 100vh;
            display: flex;
            position: relative;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        /* Loading Animation Styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #262626;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            background: transparent;
            border: 3px solid #3c3c3c;
            border-radius: 50%;
            text-align: center;
            line-height: 150px;
            font-family: sans-serif;
            font-size: 20px;
            color: #06f52e;
            letter-spacing: 4px;
            text-transform: uppercase;
            text-shadow: 0 0 10px #00ff2a;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .ring:before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-top: 3px solid #00ff2a;
            border-right: 3px solid #00ff2a;
            border-radius: 50%;
            animation: animateC 2s linear infinite;
        }

        .ring span {
            display: block;
            position: absolute;
            top: calc(50% - 2px);
            left: 50%;
            width: 50%;
            height: 4px;
            background: transparent;
            transform-origin: left;
            animation: animate 2s linear infinite;
        }

        .ring span:before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ff2a;
            top: -6px;
            right: -8px;
            box-shadow: 0 0 20px #00ff2a;
        }

        @keyframes animateC {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes animate {
            0% {
                transform: rotate(45deg);
            }
            100% {
                transform: rotate(405deg);
            }
        }

        .container {
            max-width: 100%;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 2;
            width: 100%;
        }

        .header {
            display: flex;
            align-items: center;
            padding: 20px 32px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 28px;
            background: linear-gradient(45deg, #02f82b, #1ed760);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin: 0;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        .search-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-left: auto;
            position: relative;
            z-index: 1000;
        }

        .platform-selector {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 10px 20px;
            border-radius: 24px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            outline: none;
            backdrop-filter: blur(10px);
            min-width: 120px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 40px;
        }

        .platform-selector:hover {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .platform-selector:focus {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: #1DB954;
            box-shadow: 0 0 0 2px rgba(29, 185, 84, 0.2);
        }

        .platform-selector option {
            background: #1a1a1a;
            color: #fff;
            padding: 12px;
        }

        .search-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 24px;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            width: 300px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            position: relative;
        }

        .search-bar:focus-within {
            background: rgba(255, 255, 255, 0.15);
            border-color: #1DB954;
            box-shadow: 0 0 0 2px rgba(29, 185, 84, 0.2);
            transform: translateY(-1px);
        }

        .search-bar input {
            background: none;
            border: none;
            color: #fff;
            width: 100%;
            outline: none;
            font-size: 14px;
            padding: 0;
            transition: all 0.3s ease;
        }

        .search-bar input::placeholder {
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
        }

        .search-bar:focus-within input::placeholder {
            opacity: 0.7;
            transform: translateX(4px);
        }

        .search-icon {
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .search-bar:focus-within .search-icon {
            color: #1DB954;
            transform: scale(1.1);
        }

        .search-results {
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            right: 0;
            background: rgba(18, 18, 18, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transform-origin: top;
            animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            color: #1DB954;
            font-size: 16px;
            font-weight: 500;
            background: rgba(29, 185, 84, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(29, 185, 84, 0.2);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ===== BARRA DE PROGRESSO DE DOWNLOAD ===== */
        .download-progress-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(18, 18, 18, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10000;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .download-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .download-progress-header h3 {
            margin: 0;
            color: #1DB954;
            font-size: 18px;
            font-weight: 600;
        }

        .close-progress-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .close-progress-btn:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .download-progress-content {
            margin-bottom: 20px;
        }

        .overall-progress {
            margin-bottom: 24px;
        }

        .progress-label {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #1DB954, #1ed760);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            color: #1DB954;
            font-size: 12px;
            font-weight: 600;
            text-align: right;
        }

        .playlist-progress-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .playlist-progress-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid #1DB954;
        }

        .playlist-progress-item.completed {
            border-left-color: #1DB954;
            background: rgba(29, 185, 84, 0.1);
        }

        .playlist-progress-item.error {
            border-left-color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
        }

        .playlist-progress-item.processing {
            border-left-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .playlist-name {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .playlist-status {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            margin-bottom: 6px;
        }

        .playlist-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .playlist-progress-fill {
            height: 100%;
            background: #1DB954;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .playlist-progress-text {
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            text-align: right;
        }

        .download-progress-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .download-status {
            color: #fff;
            font-size: 14px;
            font-weight: 500;
        }

        .download-stats {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .download-progress-container {
                width: 95%;
                padding: 16px;
            }

            .download-progress-header h3 {
                font-size: 16px;
            }

            .playlist-progress-list {
                max-height: 200px;
            }
        }

        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(4px);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .search-result-cover {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            margin-right: 12px;
            object-fit: cover;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .search-result-item:hover .search-result-cover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        .search-result-info {
            flex: 1;
            min-width: 0;
        }

        .search-result-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-artist {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result-platform {
            font-size: 12px;
            color: #1DB954;
            margin-left: 12px;
            padding: 4px 12px;
            border-radius: 12px;
            background: rgba(29, 185, 84, 0.1);
            border: 1px solid rgba(29, 185, 84, 0.2);
            transition: all 0.3s ease;
        }

        .search-result-item:hover .search-result-platform {
            background: rgba(29, 185, 84, 0.2);
            transform: translateY(-1px);
        }

        .import-button {
            background: #1DB954;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-left: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            transform: translateX(10px);
        }

        .search-result-item:hover .import-button {
            opacity: 1;
            transform: translateX(0);
        }

        .import-button:hover {
            background: #1ed760;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
        }

        .search-loading {
            text-align: center;
            padding: 20px;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .search-loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-top-color: #1DB954;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .search-error {
            text-align: center;
            padding: 20px;
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(255, 68, 68, 0.2);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .search-container {
                flex-direction: column;
                width: 100%;
                gap: 8px;
            }

            .platform-selector {
                width: 100%;
            }

            .search-bar {
                width: 100%;
            }

            .search-results {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 60vh;
                border-radius: 16px 16px 0 0;
                animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            @keyframes slideUp {
                from {
                    transform: translateY(100%);
                }
                to {
                    transform: translateY(0);
                }
            }
        }

        .player-section {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 24px;
            padding: 24px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        /* Botão de alternar visualização */
        .view-toggle {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 3;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            padding: 8px 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.25s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .view-toggle:hover {
            background: rgba(255, 255, 255, 0.16);
            transform: translateY(-1px);
        }

        .view-toggle .material-symbols-rounded { font-size: 20px; }

        /* Modo visualização responsivo (ampliado) */
        .player-section.view-mode {
            grid-template-columns: 1fr;
            max-width: 100vw;
            width: 100%;
            padding: 12px;
            gap: 16px;
            position: relative;
        }

        .player-section.view-mode .player-container {
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 14px;
            background: rgba(255,255,255,0.04);
            padding: 16px;
            box-shadow: 0 8px 28px rgba(0,0,0,0.35);
            transition: all 0.3s ease;
        }

        .player-section.view-mode .now-playing { gap: 20px; }

        .player-section.view-mode .album-cover {
            width: min(60vw, 520px);
            height: min(60vw, 520px);
        }

        .player-section.view-mode .track-title { font-size: clamp(24px, 5vw, 56px); }
        .player-section.view-mode .artist-name { font-size: clamp(16px, 2.8vw, 28px); }
        .player-section.view-mode .album-name { font-size: clamp(14px, 2.2vw, 22px); }

        .player-section.view-mode .controls .control-button { transform: scale(1.05); }
        .player-section.view-mode .progress-container { height: 8px; }
        .player-section.view-mode .volume-wrapper { margin-top: 8px; }

        /* Responsividade adicional */
        @media (max-width: 768px) {
            .view-toggle { top: 8px; right: 8px; }
            .player-section.view-mode .album-cover {
                width: min(80vw, 380px);
                height: min(80vw, 380px);
            }
            .player-section.view-mode .now-playing { flex-direction: column; align-items: center; }
            .player-section.view-mode .track-info { align-items: center; }
        }

        @media (max-width: 480px) {
            .player-section.view-mode .album-cover {
                width: min(88vw, 320px);
                height: min(88vw, 320px);
            }
        }

        .player-container {
            background: linear-gradient(135deg, rgba(2, 250, 89, 0.2), rgba(24, 24, 24, 0.95));
            border-radius: 16px;
            padding: 32px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .player-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
        }

        .now-playing {
            display: flex;
            gap: 32px;
            margin-bottom: 32px;
            position: relative;
        }

        .album-cover {
            width: 280px;
            height: 280px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            transition: all 0.4s ease;
            transform-origin: center;
        }

        .album-cover:hover {
            transform: scale(1.02);
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.6);
        }

        /* Estilos para borda neon na capa do álbum */
        .album-cover.neon-border {
            --neon-color: #1DB954;
            --neon-glow: 0 0 30px rgba(29, 185, 84, 0.8), 0 0 60px rgba(29, 185, 84, 0.6), 0 0 90px rgba(29, 185, 84, 0.4);
            border: 3px solid var(--neon-color);
            box-shadow: var(--neon-glow), 0 8px 24px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .album-cover.neon-border::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: conic-gradient(from 0deg, var(--neon-color), transparent, var(--neon-color), transparent, var(--neon-color));
            border-radius: 15px;
            z-index: -1;
            opacity: 0.4;
            animation: albumNeonRotate 3s linear infinite;
        }

        .album-cover.neon-border:hover {
            box-shadow: var(--neon-glow), 0 0 120px rgba(29, 185, 84, 0.5), 0 12px 32px rgba(0, 0, 0, 0.6);
            transform: scale(1.05);
        }

        @keyframes albumNeonRotate {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        .track-info {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 12px;
        }

        .track-title {
            font-size: 48px;
            font-weight: 900;
            margin: 0;
            background: linear-gradient(45deg, #fff, rgba(255, 255, 255, 0.8));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            line-height: 1.2;
        }

        .artist-name {
            color: #1DB954;
            font-size: 20px;
            font-weight: 600;
            margin: 0;
        }

        .album-name {
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
            margin: 0;
        }

        .progress-container {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin: 24px 0;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            touch-action: none;
        }

        .progress-container:hover .progress-bar {
            background: #1ed760;
        }

        .progress-container:hover::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 12px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }

        .progress-bar {
            height: 100%;
            background: #1DB954;
            border-radius: 3px;
            transition: width 0.1s linear, background-color 0.3s ease;
        }

        .time-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin: 8px 0;
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            margin-top: 32px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 24px;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .control-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.2) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .control-button:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.2);
        }

        .control-button:hover::before {
            opacity: 1;
        }

        .play-button {
            background: #1DB954;
            color: #fff;
            font-size: 32px;
            width: 64px;
            height: 64px;
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
        }

        .play-button:hover {
            background: #1ed760;
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(29, 185, 84, 0.4);
        }

        .volume-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        /* Estado escondido do container */
        .volume-container.hidden {
            max-height: 0;
            padding: 0;
            margin: 0;
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
        }

        /* Animação de transição */
        .volume-container {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Ícone de toggle */
        .toggle-icon {
            transition: transform 0.3s ease;
        }

        .volume-toggle-btn.hidden .toggle-icon {
            transform: rotate(180deg);
        }

        /* Melhorias para o ícone do botão toggle */
        .volume-toggle-btn .toggle-icon {
            font-size: 18px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .volume-toggle-btn:hover .toggle-icon {
            transform: scale(1.1);
        }

        .volume-toggle-btn.hidden .toggle-icon {
            transform: rotate(90deg) scale(1.1);
        }

        .volume-toggle-btn.hidden:hover .toggle-icon {
            transform: rotate(90deg) scale(1.2);
        }

        /* Animação de pulso para chamar atenção */
        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        .volume-toggle-btn.hidden {
            animation: pulse 2s infinite;
        }

        .volume-toggle-btn.hidden:hover {
            animation: none;
        }

        /* Wrapper para volume controls */
        .volume-wrapper {
            position: relative;
            margin-top: 32px;
        }

        .volume-toggle-btn {
            background: linear-gradient(135deg, #1DB954, #1ed760);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
            flex-shrink: 0;
        }

        .volume-toggle-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(29, 185, 84, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .volume-toggle-btn.hidden {
            background: linear-gradient(135deg, #04f799, #03fc24);
            box-shadow: 0 4px 12px rgba(6, 114, 33, 0.3);
        }

        .volume-toggle-btn.hidden:hover {
            box-shadow: 0 6px 16px rgba(44, 248, 3, 0.4);
        }

        .volume-header {
            display: flex;
            align-items: center;
            gap: 8px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            font-weight: 600;
        }

        .volume-controls {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
        }

        .volume-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .volume-label {
            display: flex;
            align-items: center;
            gap: 6px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            font-weight: 500;
            min-width: 60px;
        }

        .volume-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            transition: all 0.3s ease;
            touch-action: none;
            position: relative;
        }

        .volume-slider:hover {
            height: 8px;
            background: rgba(255, 255, 255, 0.15);
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #1DB954, #1ed760);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.3);
            box-shadow: 0 6px 16px rgba(29, 185, 84, 0.4);
        }

        .volume-slider::-webkit-slider-track {
            background: linear-gradient(90deg, rgba(29, 185, 84, 0.3), rgba(29, 185, 84, 0.1));
            border-radius: 3px;
        }

        .volume-value {
            color: #1DB954;
            font-size: 12px;
            font-weight: 600;
            min-width: 35px;
            text-align: right;
        }

        .balance-control {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(29, 185, 84, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(29, 185, 84, 0.2);
        }

        .balance-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            transition: all 0.3s ease;
        }

        .balance-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #1DB954;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(29, 185, 84, 0.3);
            transition: all 0.3s ease;
        }

        .balance-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .balance-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            font-weight: 500;
        }

        .volume-presets {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .volume-preset-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .volume-preset-btn:hover {
            background: rgba(29, 185, 84, 0.2);
            border-color: #1DB954;
            color: #1DB954;
            transform: translateY(-1px);
        }

        .volume-preset-btn.active {
            background: #1DB954;
            border-color: #1DB954;
            color: #fff;
        }

        .playlists-section {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            margin-bottom: 24px;
        }

        .playlists-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .playlists-header h3 {
            font-size: 16px;
            font-weight: 700;
            color: #fff;
            margin: 0;
        }

        .playlist-controls {
            display: flex;
            gap: 6px;
        }

        .playlist-controls .upload-button {
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 20px;
        }

        .playlist-controls .upload-button span {
            font-size: 14px;
        }

        .playlist-actions {
            display: flex;
            gap: 8px;
        }

        .playlist-actions .upload-button {
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 20px;
        }

        .playlist-actions .upload-button span {
            font-size: 14px;
        }

        .playlists-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .playlist-card {
            background: transparent;
            border: none;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .playlist-cover-container {
            position: relative;
            overflow: hidden;
            width: 80px;
            height: 80px;
            border-radius: 12px;
            margin-bottom: 8px;
        }

        .playlist-cover {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .playlist-card:hover {
            transform: translateY(-2px) scale(1.05);
        }

        .playlist-card.active {
            background: rgba(29, 185, 84, 0.1);
            border: 2px solid #1DB954;
            position: relative;
            overflow: hidden;
        }

        .playlist-card.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(29, 185, 84, 0.05) 0%, rgba(29, 185, 84, 0.15) 100%);
            z-index: 1;
            animation: activeGlow 2s ease-in-out infinite alternate;
        }

        @keyframes activeGlow {
            0% {
                box-shadow: 0 0 20px rgba(29, 185, 84, 0.3);
            }
            100% {
                box-shadow: 0 0 30px rgba(29, 185, 84, 0.6), 0 0 40px rgba(29, 185, 84, 0.4);
            }
        }

        .playlist-card.active .playlist-cover {
            transform: scale(1.05);
            filter: brightness(1.1) saturate(1.2);
        }

        .playlist-card.active h4,
        .playlist-card.active .music-count {
            position: relative;
            z-index: 2;
            color: #1DB954;
            text-shadow: 0 0 10px rgba(29, 185, 84, 0.5);
        }

        .playlist-card.active .playlist-mini-cover {
            border: 2px solid #1DB954;
            box-shadow: 0 0 8px rgba(29, 185, 84, 0.6);
            transform: scale(1.1);
        }

        .playlist-card h4 {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin: 0 0 4px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .playlist-title-with-cover {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .playlist-mini-cover {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            object-fit: cover;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .playlist-card .music-count {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
        }

        .playlist-card:hover .playlist-mini-cover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .playlist-selector {
            margin-bottom: 16px;
        }

        .playlist-selector select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            max-width: 300px;
        }

        .playlist-selector select:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .playlist {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .playlist-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .playlist-title h3 {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            margin: 0;
        }

        .upload-button {
            background: #1DB954;
            color: #fff;
            border: none;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .upload-button:hover {
            background: #1ed760;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(29, 185, 84, 0.4);
        }

        .track-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .track-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
        }

        .track-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .track-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(8px);
        }

        .track-item:hover::before {
            transform: translateX(100%);
        }

        .track-item.active {
            background: rgba(29, 185, 84, 0.1);
            border-left: 4px solid #1DB954;
        }

        .track-number {
            width: 30px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-weight: 500;
        }

        .track-info-small {
            flex: 1;
            min-width: 0;
            margin: 0 12px;
        }

        .track-title-small {
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .artist-name-small {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.6);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-duration {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            font-weight: 500;
        }

        .remove-track {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 20px;
            cursor: pointer;
            padding: 0 8px;
            opacity: 0;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .track-item:hover .remove-track {
            opacity: 1;
        }

        .remove-track:hover {
            color: #ff4444;
            transform: scale(1.2);
        }

        .clear-playlist {
            background: rgba(255, 68, 68, 0.1);
            color: #ff4444;
            border: 1px solid rgba(255, 68, 68, 0.3);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.3s ease;
            display: none;
            width: 100%;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .clear-playlist:hover {
            background: rgba(255, 68, 68, 0.2);
            transform: translateY(-2px);
        }

        @media (max-width: 1200px) {
            .player-section {
                grid-template-columns: 1fr;
                max-width: 800px;
                padding: 16px;
            }

            .playlist {
                height: 400px;
                overflow-y: auto;
            }

            .track-title {
                font-size: 36px;
            }

            .album-cover {
                width: 240px;
                height: 240px;
            }

            .now-playing {
                gap: 24px;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 12px 16px;
                flex-direction: column;
                gap: 12px;
            }

            .header h1 {
                font-size: 24px;
            }

            .search-bar {
                width: 100%;
                max-width: 300px;
                margin: 0 auto;
            }

            .player-section {
                padding: 12px;
            }

            .player-container {
                padding: 16px;
            }

            .now-playing {
                flex-direction: column;
                text-align: center;
                gap: 20px;
                align-items: center;
                justify-content: center;
            }

            .album-cover {
                display: block;
                margin-left: auto;
                margin-right: auto;
                margin-bottom: 0;
            }

            .track-info {
                align-items: center;
            }

            .track-title {
                font-size: 28px;
            }

            .artist-name {
                font-size: 18px;
            }

            .album-name {
                font-size: 14px;
            }

            .controls {
                gap: 12px;
            }

            .control-button {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }

            .play-button {
                width: 48px;
                height: 48px;
                font-size: 24px;
            }

            .volume-container {
                margin-top: 20px;
                padding: 8px;
            }

            .volume-slider {
                width: 100px;
            }
        }

        @media (max-width: 480px) {
            .header {
                padding: 10px;
            }

            .header h1 {
                font-size: 20px;
            }

            .player-section {
                padding: 8px;
            }

            .player-container {
                padding: 12px;
            }

            .album-cover {
                width: 180px;
                height: 180px;
            }

            .track-title {
                font-size: 24px;
            }

            .artist-name {
                font-size: 16px;
            }

            .album-name {
                font-size: 12px;
            }

            .controls {
                gap: 8px;
            }

            .control-button {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }

            .play-button {
                width: 44px;
                height: 44px;
                font-size: 22px;
            }

            .volume-container {
                margin-top: 16px;
                padding: 6px;
            }

            .volume-slider {
                width: 80px;
            }

            .track-item {
                padding: 8px 12px;
            }

            .track-title-small {
                font-size: 14px;
            }

            .artist-name-small {
                font-size: 12px;
            }

            .track-duration {
                font-size: 10px;
            }

            .playlist-title h3 {
                font-size: 20px;
            }

            .upload-button {
                padding: 8px 16px;
                font-size: 12px;
            }

            .volume-toggle-btn {
                width: 20px;
                height: 20px;
                font-size: 12px;
            }
        }

        @media (max-height: 480px) and (orientation: landscape) {
            .player-section {
                grid-template-columns: 1fr 300px;
            }

            .now-playing {
                flex-direction: row;
                text-align: left;
            }

            .album-cover {
                width: 120px;
                height: 120px;
            }

            .track-title {
                font-size: 20px;
            }

            .artist-name {
                font-size: 14px;
            }

            .album-name {
                font-size: 12px;
            }

            .controls {
                margin-top: 16px;
            }

            .playlist {
                height: 300px;
            }
        }

        @media (min-width: 768px) and (max-width: 1024px) {
            .player-section {
                grid-template-columns: 1fr 350px;
                gap: 16px;
            }

            .album-cover {
                width: 220px;
                height: 220px;
            }

            .track-title {
                font-size: 32px;
            }

            .playlist {
                height: 450px;
            }
        }

        @media (min-width: 1400px) {
            .player-section {
                max-width: 1600px;
                grid-template-columns: 1fr 400px;
            }

            .album-cover {
                width: 320px;
                height: 320px;
            }

            .track-title {
                font-size: 52px;
            }

            .artist-name {
                font-size: 24px;
            }

            .album-name {
                font-size: 18px;
            }

            .playlist {
                height: 600px;
            }
        }

        @media (hover: none) {
            .control-button:hover,
            .upload-button:hover,
            .remove-track:hover,
            .clear-playlist:hover {
                transform: none;
            }

            .track-item:hover {
                transform: none;
            }

            .album-cover:hover {
                transform: none;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideIn {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .track-item {
            animation: slideIn 0.3s ease-out forwards;
        }

        .player-container {
            animation: fadeIn 0.5s ease-out;
        }

        .deezer-embed {
            width: 100%;
            height: 350px;
            margin: 20px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .deezer-embed iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        @media (max-width: 768px) {
            .deezer-embed {
                height: 250px;
            }
        }

        @media (max-width: 480px) {
            .deezer-embed {
                height: 200px;
            }
        }

        .loading {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            padding: 20px;
            font-style: italic;
        }

        .error {
            text-align: center;
            color: #ff4444;
            padding: 20px;
        }

        .add-track {
            background: none;
            border: none;
            color: #1DB954;
            font-size: 20px;
            cursor: pointer;
            padding: 0 8px;
            opacity: 0;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .track-item:hover .add-track {
            opacity: 1;
        }

        .add-track:hover {
            color: #1ed760;
            transform: scale(1.2);
        }

        .track-item.deezer {
            background: rgba(29, 185, 84, 0.05);
            border-left: 4px solid #1DB954;
        }

        /* Estilos para borda neon dinâmica */
        .track-item.neon-border {
            --neon-color: #1DB954;
            --neon-glow: 0 0 20px rgba(29, 185, 84, 0.6), 0 0 40px rgba(29, 185, 84, 0.4), 0 0 60px rgba(29, 185, 84, 0.2);
            border: 2px solid var(--neon-color);
            box-shadow: var(--neon-glow);
            position: relative;
        }

        .track-item.neon-border::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--neon-color), transparent, var(--neon-color));
            border-radius: 10px;
            z-index: -1;
            opacity: 0.3;
            animation: neonPulse 2s ease-in-out infinite alternate;
        }

        .track-item.neon-border:hover {
            box-shadow: var(--neon-glow), 0 0 80px rgba(29, 185, 84, 0.3);
            transform: translateX(8px) scale(1.02);
        }

        @keyframes neonPulse {
            0% {
                opacity: 0.3;
                transform: scale(1);
            }
            100% {
                opacity: 0.6;
                transform: scale(1.01);
            }
        }

        .material-symbols-rounded {
            font-variation-settings:
                'FILL' 0,
                'wght' 400,
                'GRAD' 0,
                'opsz' 24;
            vertical-align: middle;
        }

        /* Estilos para os ícones de fone */
        .headphone-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #1DB954, #1ed760);
            border-radius: 50%;
            color: #fff;
            font-weight: bold;
            font-size: 10px;
            margin-right: 4px;
            box-shadow: 0 2px 4px rgba(29, 185, 84, 0.3);
            transition: all 0.3s ease;
        }

        .headphone-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(29, 185, 84, 0.4);
        }

        /* Melhorias para os controles de volume */
        .volume-row:hover .volume-label {
            color: #1DB954;
        }

        .volume-row:hover .volume-slider {
            background: rgba(29, 185, 84, 0.2);
        }

        .balance-control:hover {
            background: rgba(29, 185, 84, 0.15);
            border-color: rgba(29, 185, 84, 0.3);
        }

        /* Container para volume value e botão toggle */
        .volume-value-container {
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        /* Animação para os valores de volume */
        .volume-value {
            transition: all 0.3s ease;
        }

        .volume-row:hover .volume-value {
            transform: scale(1.1);
            color: #1ed760;
        }

        /* Responsividade para os controles de volume */
        @media (max-width: 768px) {
            .volume-container {
                padding: 16px;
            }

            .volume-controls {
                gap: 12px;
            }

            .volume-row {
                gap: 8px;
            }

            .volume-label {
                min-width: 50px;
                font-size: 11px;
            }

            .volume-value {
                min-width: 30px;
                font-size: 11px;
            }

            .volume-value-container {
                gap: 4px;
            }

            .volume-presets {
                flex-wrap: wrap;
                gap: 6px;
            }

            .volume-preset-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
        }

        /* Controles Avançados */
        .volume-advanced-controls {
            display: block;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .volume-container.hidden .volume-advanced-controls {
            display: none;
        }

        /* Controle Simples */
        .volume-simple-control {
            display: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .volume-container.hidden .volume-simple-control {
            display: block;
        }

        /* Esconde o botão simples quando controles avançados estão visíveis */
        .volume-simple-control .volume-toggle-btn {
            display: flex;
        }

        .volume-advanced-controls .volume-toggle-btn {
            display: flex;
        }

        .simple-volume-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .simple-volume-row:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .simple-volume-row .material-symbols-rounded {
            color: #1DB954;
            font-size: 20px;
        }

        .simple-volume-row .volume-slider {
            flex: 1;
            height: 6px;
        }

        .simple-volume-row .volume-value {
            color: #1DB954;
            font-size: 12px;
            font-weight: 600;
            min-width: 35px;
            text-align: right;
        }

        /* Melhorias para o controle simples */
        .volume-container.hidden {
            max-height: none;
            padding: 12px;
            margin-top: 32px;
            opacity: 1;
            transform: none;
            pointer-events: auto;
        }

        .volume-container.hidden .volume-simple-control {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsividade para o controle simples */
        @media (max-width: 768px) {
            .simple-volume-row {
                padding: 8px;
                gap: 8px;
            }

            .simple-volume-row .material-symbols-rounded {
                font-size: 18px;
            }

            .simple-volume-row .volume-value {
                font-size: 11px;
                min-width: 30px;
            }
        }

                    /* Ajustes para o botão toggle em mobile */
            .volume-toggle-btn {
                width: 20px;
                height: 20px;
                font-size: 12px;
            }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/jsmediatags@3.9.7/dist/jsmediatags.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" rel="stylesheet" />
</head>
<body>
    <!-- Loading Animation -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="ring">Loading
            <span></span>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <h1>Musickêra</h1>
            <div class="search-container">
                <select class="platform-selector" id="platformSelector">
                    <option value="Sua Juckebox">Juckebox</option>
                    <option value="spotify">Spotify</option>
                    <option value="deezer">Deezer</option>
                    <option value="youtube">YouTube Music</option>
                    <option value="suamusica">Sua Música</option>
                    <option value="4shared">4 Shared</option>
                </select>
                <div class="search-bar">
                    <span class="search-icon">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"></circle>
                            <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                        </svg>
                    </span>
                    <input type="text" placeholder="Buscar músicas ou playlists..." id="searchInput">
                </div>
                <button class="upload-button" id="importYtBtn" title="Importar playlist Youtube Music"><span class="material-symbols-rounded">
                    youtube_activity
                    </span></button>
                <button class="upload-button" id="syncBtn" title="Forçar sincronização com a pasta musics">
                    <span class="material-symbols-rounded">sync</span> 
                </button>
                <button class="upload-button" id="loadAllBtn" title=" Barra de progresso">
                    <span class="material-symbols-rounded">playlist_add_check_circle</span>
                </button>
                <div class="search-results" id="searchResults">
                    <!-- Search results will be populated here -->
                </div>
            </div>
        </div>

        <!-- Barra de Progresso de Download -->
        <div id="downloadProgressBar" class="download-progress-container" style="display: none;">
            <div class="download-progress-header">
                <h3>📥 Carregando Playlists</h3>
                <button id="closeProgressBar" class="close-progress-btn">×</button>
            </div>
            <div class="download-progress-content">
                <div class="overall-progress">
                    <div class="progress-label">Progresso Geral</div>
                    <div class="progress-bar-container">
                        <div id="overallProgressBar" class="progress-bar-fill"></div>
                    </div>
                    <div id="overallProgressText" class="progress-text">0%</div>
                </div>
                <div id="playlistProgressList" class="playlist-progress-list">
                    <!-- Lista de progresso das playlists será inserida aqui -->
                </div>
            </div>
            <div class="download-progress-footer">
                <div id="downloadStatus" class="download-status">Iniciando carregamento...</div>
                <div id="downloadStats" class="download-stats">
                    <span id="processedFiles">0</span> / <span id="totalFiles">0</span> arquivos
                </div>
            </div>
        </div>

        <div class="player-section">
            <button class="view-toggle" id="viewToggleBtn" title="Ampliar / Modo Visualização">
                <span class="material-symbols-rounded">fullscreen</span>
            </button>
            <div class="player-container">
                <div class="now-playing">
                    <img src="musics/default-cover.jpg" alt="Album Cover" class="album-cover">
                    <div class="track-info">
                        <h2 class="track-title">Nome da Música</h2>
                        <p class="artist-name">Artista</p>
                        <p class="album-name">Álbum</p>
                        <p class="Ano">Ano de Lançamento</p>

                    </div>
                </div>

                <div class="progress-container">
                    <div class="progress-bar"></div>
                </div>

                <div class="time-info">
                    <span class="current-time">0:00</span>
                    <span class="duration">0:00</span>
                </div>

                <div class="controls">
                    <button class="control-button" onclick="previousTrack()" title="Anterior">
                        <span class="material-symbols-rounded">skip_previous</span>
                    </button>
                    <button class="control-button" onclick="togglePlay()" title="Play/Pause">
                        <span id="playPauseIcon" class="material-symbols-rounded">play_arrow</span>
                    </button>
                    <button class="control-button" onclick="nextTrack()" title="Próxima">
                        <span class="material-symbols-rounded">skip_next</span>
                    </button>
                    <button class="control-button" onclick="toggleRepeat()" id="repeatButton" title="Repetir">
                        <span id="repeatIcon" class="material-symbols-rounded">repeat</span>
                    </button>
                </div>

                <!-- Wrapper para volume controls -->
                <div class="volume-wrapper">
                    <div class="volume-container">
                    <!-- Controles Avançados -->
                    <div class="volume-advanced-controls">
                        <div class="volume-header">
                            <span class="material-symbols-rounded">volume_up</span>
                            <span>Controles de Volume</span>
                        </div>
                        
                        <div class="volume-controls">
                            <!-- Volume Master -->
                            <div class="volume-row">
                                <div class="volume-label">
                                    <span class="material-symbols-rounded">volume_up</span>
                                    Master
                                </div>
                                <input type="range" class="volume-slider" id="masterVolume" min="0" max="100" value="100">
                                <div class="volume-value-container">
                                    <span class="volume-value" id="masterVolumeValue">100%</span>
                                    <button class="volume-toggle-btn" id="volumeToggleBtn" title="Esconder/Mostrar Controles de Volume">
                                        <span class="material-symbols-rounded toggle-icon">settings</span>
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Volume Canal Esquerdo -->
                            <div class="volume-row">
                                <div class="volume-label">
                                    <span class="material-symbols-rounded">headphones</span>
                                    <span class="headphone-icon">D</span>
                                </div>
                                <input type="range" class="volume-slider" id="leftVolume" min="0" max="100" value="100">
                                <span class="volume-value" id="leftVolumeValue">100%</span>
                            </div>
                            
                            <!-- Volume Canal Direito -->
                            <div class="volume-row">
                                <div class="volume-label">
                                    <span class="material-symbols-rounded">headphones</span>
                                    <span class="headphone-icon">R</span>
                                </div>
                                <input type="range" class="volume-slider" id="rightVolume" min="0" max="100" value="100">
                                <span class="volume-value" id="rightVolumeValue">100%</span>
                            </div>
                            
                            <!-- Controle de Balance -->
                            <div class="balance-control">
                                <div class="balance-label">
                                    <span class="material-symbols-rounded">balance</span>
                                    Balance
                                </div>
                                <input type="range" class="balance-slider" id="balanceSlider" min="-100" max="100" value="0">
                                <span class="volume-value" id="balanceValue">C</span>
                            </div>
                            
                            <!-- Presets de Volume -->
                            <div class="volume-presets">
                                <button class="volume-preset-btn" onclick="setVolumePreset(25)">25%</button>
                                <button class="volume-preset-btn" onclick="setVolumePreset(50)">50%</button>
                                <button class="volume-preset-btn" onclick="setVolumePreset(75)">75%</button>
                                <button class="volume-preset-btn" onclick="setVolumePreset(100)">100%</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Controle Simples (quando avançado está escondido) -->
                    <div class="volume-simple-control">
                        <div class="simple-volume-row">
                            <span class="material-symbols-rounded">volume_up</span>
                            <input type="range" class="volume-slider" id="simpleVolume" min="0" max="100" value="100">
                            <div class="volume-value-container">
                                <span class="volume-value" id="simpleVolumeValue">100%</span>
                                <button class="volume-toggle-btn" id="volumeToggleBtnSimple" title="Esconder/Mostrar Controles de Volume">
                                    <span class="material-symbols-rounded toggle-icon">tune</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            </div>

            <div class="playlists-section">
                <div class="playlists-header">
                    <h3>Playlists</h3>
                    <div class="playlist-controls">
                        <button class="upload-button" onclick="showCreatePlaylistModal()">
                            <span class="material-symbols-rounded">playlist_add</span>Nova
                        </button>
                        <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                            <span class="material-symbols-rounded">upload</span> Upload
                        </button>
                    </div>
                </div>
                
                <div class="playlists-list" id="playlistsList">
                    <!-- Lista de playlists será preenchida dinamicamente -->
                </div>
                
                <div class="playlist-selector">
                    <select id="playlistSelector" onchange="loadPlaylist(this.value)">
                        <option value="">Jukebox</option>
                    </select>
                </div>
            </div>

            <div class="playlist">
                <div class="playlist-title">
                    <h3 id="currentPlaylistTitle">Todas as Músicas
                    <div class="playlist-actions">
                        <button class="upload-button" onclick="showUploadModal()">
                            <span class="material-symbols-rounded">upload</span> Upload para Playlist
                        </button>
                        <button class="upload-button" onclick="debugPlaylist()" style="background: #ff6b6b;">
                            <span class="material-symbols-rounded">bug_report</span> Verificar
                        </button>
                    </div>
                </div>
                <input type="file" id="fileInput" accept="audio/*" multiple onchange="handleFileUpload(event)" style="display: none;">
                <ul class="track-list">
                    <!-- A lista será preenchida dinamicamente pelo JavaScript -->
                </ul>
                <button class="clear-playlist" onclick="clearPlaylist()" style="display: none;">Limpar Playlist</button>
            </div>
        </div>
    </div>

    <audio id="playerAudio" preload="metadata" crossorigin="anonymous"></audio>

    <script>
        const playlist = [
            {
                title: "Titulo da Música",
                artist: "Nome do Artista",
                album: "Nome do Album",
                duration: "3:45",
                cover: "/",
                file: "musica.mp3",
                trackNumber: 1
            },
            

           
        ];

        let currentTrack = 0;
        let isPlaying = false;
        let audio = document.getElementById('playerAudio');
        let repeatMode = 'none'; // 'none', 'one', 'all'

        // Base de API/backend para recursos (configurável via window.API_BASE_URL ou localStorage)
        const API_BASE_URL = (typeof window !== 'undefined' && (window.API_BASE_URL || localStorage.getItem('API_BASE_URL'))) || 'http://localhost:5000';

        // Loading Animation Control Functions
        function showLoading() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.classList.remove('hidden');
                loadingOverlay.style.display = 'flex';
            }
        }

        function hideLoading() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            if (loadingOverlay) {
                loadingOverlay.classList.add('hidden');
                // Remove the overlay from DOM after animation completes
                setTimeout(() => {
                    if (loadingOverlay && loadingOverlay.classList.contains('hidden')) {
                        loadingOverlay.style.display = 'none';
                    }
                }, 500); // Match the CSS transition duration
            }
        }

        // Function to check if loading should be hidden when music is added
        function checkAndHideLoadingIfMusicReady() {
            if (playlist.length > 0 && currentTrack < playlist.length) {
                const track = playlist[currentTrack];
                if (track && track.file) {
                    // If there's a current track with a file, loadTrack will handle hiding the loading
                    return;
                }
            }
            // If no music is ready, keep loading visible
        }

        // ===== SISTEMA DE FILAS DE TAREFAS EM SEGUNDO PLANO =====
        
        // Sistema de filas para operações não-críticas
        const backgroundTaskQueue = {
            tasks: [],
            isProcessing: false,
            maxConcurrentTasks: 2,
            activeTasks: 0,
            
            // Adiciona tarefa à fila
            addTask(task, priority = 'normal') {
                const taskItem = {
                    id: Date.now() + Math.random(),
                    task,
                    priority,
                    addedAt: Date.now()
                };
                
                if (priority === 'high') {
                    this.tasks.unshift(taskItem);
                } else {
                    this.tasks.push(taskItem);
                }
                
                this.processQueue();
            },
            
            // Processa a fila de tarefas
            async processQueue() {
                if (this.isProcessing || this.activeTasks >= this.maxConcurrentTasks) {
                    return;
                }
                
                this.isProcessing = true;
                
                while (this.tasks.length > 0 && this.activeTasks < this.maxConcurrentTasks) {
                    const taskItem = this.tasks.shift();
                    this.activeTasks++;
                    
                    try {
                        await taskItem.task();
                    } catch (error) {
                        console.error('Erro na tarefa em segundo plano:', error);
                    } finally {
                        this.activeTasks--;
                    }
                }
                
                this.isProcessing = false;
                
                // Continua processando se ainda há tarefas
                if (this.tasks.length > 0) {
                    setTimeout(() => this.processQueue(), 100);
                }
            },
            
            // Limpa a fila
            clearQueue() {
                this.tasks = [];
            }
        };

        // Sistema de proteção de continuidade musical
        const musicContinuityProtection = {
            isPlaying: false,
            currentTrackId: null,
            protectionActive: false,
            
            // Ativa proteção durante operações críticas
            activateProtection() {
                this.protectionActive = true;
                this.isPlaying = isPlaying;
                this.currentTrackId = currentTrack;
                console.log('🛡️ Proteção de continuidade musical ativada');
            },
            
            // Desativa proteção
            deactivateProtection() {
                this.protectionActive = false;
                console.log('🛡️ Proteção de continuidade musical desativada');
            },
            
            // Verifica se deve pausar operações
            shouldPauseOperations() {
                return this.protectionActive && this.isPlaying;
            },
            
            // Restaura estado de reprodução se necessário
            restorePlaybackState() {
                if (this.protectionActive && this.isPlaying && !isPlaying) {
                    console.log('🔄 Restaurando estado de reprodução');
                    togglePlay();
                }
            }
        };

        // Sistema de atualizações de UI diferidas
        const deferredUIUpdates = {
            pendingUpdates: new Set(),
            updateTimeout: null,
            
            // Agenda atualização de UI
            scheduleUpdate(updateFunction, delay = 100) {
                this.pendingUpdates.add(updateFunction);
                
                if (this.updateTimeout) {
                    clearTimeout(this.updateTimeout);
                }
                
                this.updateTimeout = setTimeout(() => {
                    this.executePendingUpdates();
                }, delay);
            },
            
            // Executa todas as atualizações pendentes
            executePendingUpdates() {
                if (this.pendingUpdates.size === 0) return;
                
                console.log(`🎨 Executando ${this.pendingUpdates.size} atualizações de UI`);
                
                this.pendingUpdates.forEach(updateFunction => {
                    try {
                        updateFunction();
                    } catch (error) {
                        console.error('Erro na atualização de UI:', error);
                    }
                });
                
                this.pendingUpdates.clear();
                this.updateTimeout = null;
            },
            
            // Força execução imediata
            forceUpdate() {
                if (this.updateTimeout) {
                    clearTimeout(this.updateTimeout);
                }
                this.executePendingUpdates();
            }
        };

        // Show loading on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Keep loading visible until music is loaded
            // Loading will be hidden by loadTrack() when music is ready
        });

        function resolveCoverUrl(coverPath) {
            const path = coverPath || 'musics/default-cover.jpg';
            if (!path) return '';
            const lower = String(path).toLowerCase();
            if (lower.startsWith('http://') || lower.startsWith('https://') || lower.startsWith('data:') || lower.startsWith('blob:')) {
                return path;
            }
            const normalized = path.startsWith('/') ? path : `/${path}`;
            if (normalized.startsWith('/musics/')) {
                const fullUrl = `${API_BASE_URL}${normalized}`;
                console.log(`🔗 Resolvendo cover URL: ${path} -> ${fullUrl}`);
                return fullUrl;
            }
            return path;
        }

        // Configuração do IndexedDB
        const dbName = 'MusickeraDB';
        const dbVersion = 2;
        let db;

        // Função para inicializar o banco de dados
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, dbVersion);

                request.onerror = (event) => {
                    console.error('Erro ao abrir o banco de dados:', event.target.error);
                    reject(event.target.error);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('Banco de dados aberto com sucesso');
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Cria o object store para as músicas ou atualiza índices
                    if (!db.objectStoreNames.contains('musics')) {
                        const musicStore = db.createObjectStore('musics', { keyPath: 'id', autoIncrement: true });
                        musicStore.createIndex('title', 'title', { unique: false });
                        musicStore.createIndex('artist', 'artist', { unique: false });
                        musicStore.createIndex('album', 'album', { unique: false });
                        musicStore.createIndex('fileName', 'fileName', { unique: false });
                    } else {
                        const musicStore = event.target.transaction.objectStore('musics');
                        if (!musicStore.indexNames.contains('fileName')) {
                            musicStore.createIndex('fileName', 'fileName', { unique: false });
                        }
                    }
                };
            });
        }

        // Função para salvar uma música no banco de dados
        async function saveMusicToDB(music) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['musics'], 'readwrite');
                const store = transaction.objectStore('musics');
                
                const request = store.add(music);
                
                request.onsuccess = () => {
                    console.log('Música salva no banco de dados');
                    resolve(request.result);
                };
                
                request.onerror = (event) => {
                    console.error('Erro ao salvar música:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // Função para carregar todas as músicas do banco de dados
        async function loadMusicsFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['musics'], 'readonly');
                const store = transaction.objectStore('musics');
                const request = store.getAll();
                
                request.onsuccess = () => {
                    console.log('Músicas carregadas do banco de dados');
                    resolve(request.result);
                };
                
                request.onerror = (event) => {
                    console.error('Erro ao carregar músicas:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // Função para remover uma música do banco de dados
        async function removeMusicFromDB(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['musics'], 'readwrite');
                const store = transaction.objectStore('musics');
                const request = store.delete(id);
                
                request.onsuccess = () => {
                    console.log('Música removida do banco de dados');
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error('Erro ao remover música:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // Função para limpar todas as músicas do banco de dados
        async function clearMusicDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['musics'], 'readwrite');
                const store = transaction.objectStore('musics');
                const request = store.clear();
                
                request.onsuccess = () => {
                    console.log('Banco de dados limpo');
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error('Erro ao limpar banco de dados:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // Busca uma música pelo nome do arquivo (para evitar duplicados)
        async function getMusicByFileName(fileName) {
            return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction(['musics'], 'readonly');
                    const store = transaction.objectStore('musics');
                    const index = store.index('fileName');
                    const request = index.get(fileName);

                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = (event) => reject(event.target.error);
                } catch (err) {
                    reject(err);
                }
            });
        }

        // Função para deletar uma música do banco de dados
        async function deleteMusicFromDB(id) {
            return new Promise((resolve, reject) => {
                try {
                    const transaction = db.transaction(['musics'], 'readwrite');
                    const store = transaction.objectStore('musics');
                    const request = store.delete(id);
                    
                    request.onsuccess = () => {
                        console.log('Música removida do banco de dados');
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        console.error('Erro ao remover música do banco de dados:', event.target.error);
                        reject(event.target.error);
                    };
                } catch (err) {
                    reject(err);
                }
            });
        }

        // Atualiza/insere música no DB
        async function updateMusicInDB(music) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['musics'], 'readwrite');
                const store = transaction.objectStore('musics');
                const request = store.put(music);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function arrayBufferToBlobUrl(arrayBuffer, mimeType) {
            try {
                if (!arrayBuffer || arrayBuffer.byteLength === 0) {
                    throw new Error('ArrayBuffer vazio ou inválido');
                }
                
                const blob = new Blob([arrayBuffer], { type: mimeType || 'audio/mpeg' });
                const url = URL.createObjectURL(blob);
                
                if (!url) {
                    throw new Error('Falha ao criar URL do blob');
                }
                
                return url;
            } catch (error) {
                console.error('Erro ao criar blob URL:', error);
                throw error;
            }
        }

        // Função para extrair cor dominante de uma imagem
        function getDominantColor(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    let r = 0, g = 0, b = 0;
                    let pixelCount = 0;
                    
                    // Amostra pixels para melhor performance
                    for (let i = 0; i < data.length; i += 16) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        pixelCount++;
                    }
                    
                    r = Math.floor(r / pixelCount);
                    g = Math.floor(g / pixelCount);
                    b = Math.floor(b / pixelCount);
                    
                    resolve(`rgb(${r}, ${g}, ${b})`);
                };
                img.onerror = () => resolve('#1DB954'); // Cor padrão se falhar
                img.src = imageUrl;
            });
        }

        // Função para aplicar borda neon no card de música ou capa do álbum
        async function applyNeonBorder(element, imageUrl) {
            try {
                const dominantColor = await getDominantColor(imageUrl);
                const rgb = dominantColor.match(/\d+/g);
                if (rgb && rgb.length >= 3) {
                    const [r, g, b] = rgb;
                    element.style.setProperty('--neon-color', dominantColor);
                    
                    // Diferentes efeitos para cards de música vs capa do álbum
                    if (element.classList.contains('album-cover')) {
                        // Efeito mais intenso para a capa do álbum
                        element.style.setProperty('--neon-glow', `0 0 30px rgba(${r}, ${g}, ${b}, 0.8), 0 0 60px rgba(${r}, ${g}, ${b}, 0.6), 0 0 90px rgba(${r}, ${g}, ${b}, 0.4)`);
                    } else {
                        // Efeito mais sutil para os cards de música
                        element.style.setProperty('--neon-glow', `0 0 20px rgba(${r}, ${g}, ${b}, 0.6), 0 0 40px rgba(${r}, ${g}, ${b}, 0.4), 0 0 60px rgba(${r}, ${g}, ${b}, 0.2)`);
                    }
                    
                    element.classList.add('neon-border');
                }
            } catch (error) {
                console.log('Erro ao aplicar borda neon:', error);
            }
        }

        // Remove duplicados da playlist (e do IndexedDB quando aplicável)
        async function dedupePlaylistAndDB() {
            const normalize = (s) => (s || '').toLowerCase().trim().replace(/\s+/g, ' ');
            const makeKey = (track) => {
                if (track.fileName) return `file:${normalize(track.fileName)}`;
                if (track.source === 'deezer' && track.deezerId) return `deezer:${track.deezerId}`;
                if (track.source === 'youtube' && track.youtubeId) return `yt:${track.youtubeId}`;
                return `meta:${normalize(track.artist)}|${normalize(track.title)}|${normalize(track.album)}`;
            };

            const seen = new Set();
            const toRemove = [];
            playlist.forEach((t, idx) => {
                const key = makeKey(t);
                if (seen.has(key)) {
                    toRemove.push(idx);
                } else {
                    seen.add(key);
                }
            });

            if (toRemove.length === 0) return;

            for (let i = toRemove.length - 1; i >= 0; i--) {
                const idx = toRemove[i];
                const track = playlist[idx];
                if (track && track.id) {
                    try { await removeMusicFromDB(track.id); } catch (e) { console.error('Falha ao remover duplicado do DB:', e); }
                }
                playlist.splice(idx, 1);
                if (currentTrack >= idx && currentTrack > 0) currentTrack--;
            }

            sortPlaylist();
            updatePlaylistHTML();
            if (playlist.length > 0) {
                loadTrack();
            }
        }

        function updatePlayerInfo(track) {
            if (track.source === 'deezer') {
                // Para músicas do Deezer, não atualiza o player padrão
                return;
            }
            
            document.querySelector('.track-title').textContent = track.title;
            document.querySelector('.artist-name').textContent = track.artist;
            document.querySelector('.album-name').textContent = track.album;
            const coverEl = document.querySelector('.album-cover');
            if (coverEl) {
                coverEl.classList.add('cover-loading');
                const newSrc = resolveCoverUrl(track.cover);
                coverEl.onload = () => {
                    coverEl.classList.remove('cover-loading');
                };
                coverEl.onerror = () => {
                    coverEl.src = resolveCoverUrl('musics/default-cover.jpg');
                    coverEl.classList.remove('cover-loading');
                };
                coverEl.src = newSrc;
                coverEl.alt = `${track.title} - ${track.artist}`;
            }
            document.querySelector('.duration').textContent = track.duration;
            const yearEl = document.querySelector('.Ano');
            if (yearEl) yearEl.textContent = track.year ? `Ano: ${track.year}` : '';
            
            // Aplica borda neon na capa do álbum
            const albumCover = document.querySelector('.album-cover');
            if (albumCover && track.cover && track.cover !== 'musics/default-cover.jpg') {
                applyNeonBorder(albumCover, resolveCoverUrl(track.cover));
            }
            
            // Atualiza a lista de reprodução
            const trackItems = document.querySelectorAll('.track-item');
            trackItems.forEach((item, index) => {
                item.classList.toggle('active', index === currentTrack);
            });
        }

        function nextTrack() {
            currentTrack = (currentTrack + 1) % playlist.length;
            loadTrack();
            // Atualiza o botão de play para mostrar o estado correto
            document.querySelector('.control-button:nth-child(2)').textContent = isPlaying ? '⏸' : '⏯';
        }

        function previousTrack() {
            currentTrack = (currentTrack - 1 + playlist.length) % playlist.length;
            loadTrack();
            // Atualiza o botão de play para mostrar o estado correto
            document.querySelector('.control-button:nth-child(2)').textContent = isPlaying ? '⏸' : '⏯';
        }

        function loadTrack() {
            const track = playlist[currentTrack];
            
            console.log('Carregando faixa:', track);
            
            if (!track) {
                console.error('Nenhuma faixa encontrada para reproduzir');
                return;
            }
            
            if (track.source === 'deezer') {
                // Para músicas do Deezer, carrega o player incorporado
                const playerContainer = document.querySelector('.player-container');
                const embedHtml = `
                    <div class="now-playing">
                        <img src="${resolveCoverUrl(track.cover)}" alt="${track.title}" class="album-cover">
                        <div class="track-info">
                            <h2 class="track-title">${track.title}</h2>
                            <p class="artist-name">${track.artist}</p>
                            <p class="album-name">${track.album}</p>
                        </div>
                    </div>
                    <div class="deezer-embed">
                        <iframe scrolling="no" frameborder="0" allowTransparency="true" 
                            src="https://www.deezer.com/plugins/player?format=classic&autoplay=${isPlaying ? 1 : 0}&playlist=true&width=700&height=350&color=007FEB&layout=dark&size=medium&type=tracks&id=${track.deezerId}&app_id=1"
                            width="700" height="350">
                        </iframe>
                    </div>
                `;
                playerContainer.innerHTML = embedHtml;
            } else if (track.source === 'youtube') {
                // For YouTube Music, create an embedded player
                const playerContainer = document.querySelector('.player-container');
                const embedHtml = `
                    <div class="now-playing">
                        <img src="${resolveCoverUrl(track.cover)}" alt="${track.title}" class="album-cover">
                        <div class="track-info">
                            <h2 class="track-title">${track.title}</h2>
                            <p class="artist-name">${track.artist}</p>
                        </div>
                    </div>
                    <div class="youtube-embed">
                        <iframe 
                            width="100%" 
                            height="350" 
                            src="https://www.youtube.com/embed/${track.youtubeId}?autoplay=${isPlaying ? 1 : 0}&enablejsapi=1" 
                            frameborder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            allowfullscreen>
                        </iframe>
                    </div>
                `;
                playerContainer.innerHTML = embedHtml;
            } else {
                // Para músicas locais, usa o player padrão
                try {
                    console.log('Processando música local:', {
                        title: track.title,
                        hasFile: !!track.file,
                        hasFileArrayBuffer: !!track.fileArrayBuffer,
                        fileType: track.fileType,
                        fileName: track.fileName
                    });

                    // Verifica se o arquivo existe
                    if (!track.file && !track.fileArrayBuffer) {
                        console.error('Arquivo de música não encontrado:', track);
                        alert('Arquivo de música não encontrado. Tente recarregar a página.');
                        return;
                    }

                    // Cria URL do blob se necessário
                    if (!track.file && track.fileArrayBuffer) {
                        try {
                            console.log('Criando blob URL para:', track.fileName);
                            const blob = new Blob([track.fileArrayBuffer], { 
                                type: track.fileType || 'audio/mpeg' 
                            });
                            track.file = URL.createObjectURL(blob);
                            console.log('Blob URL criado:', track.file);
                        } catch (e) {
                            console.error('Falha ao criar URL do blob para a faixa:', e);
                            alert('Erro ao processar o arquivo de música. Tente fazer upload novamente.');
                            return;
                        }
                    }

                    // Verifica se o arquivo é um URL válido
                    if (typeof track.file === 'string' && !track.file.startsWith('blob:') && !track.file.startsWith('http')) {
                        console.error('URL do arquivo inválido:', track.file);
                        alert('URL do arquivo inválido. Tente recarregar a página.');
                        return;
                    }

                    console.log('Definindo src do áudio:', track.file);
                    
                    // Carrega o áudio
                    audio.src = track.file;
                    audio.load();
                    
                    // Atualiza as informações do player
                    updatePlayerInfo(track);
                    
                    // Reproduz se estiver no estado de reprodução
                    if (isPlaying) {
                        console.log('Tentando reproduzir áudio...');
                        audio.play().catch(error => {
                            console.error('Erro ao reproduzir áudio:', error);
                            console.error('Detalhes do erro:', {
                                name: error.name,
                                message: error.message,
                                code: audio.error ? audio.error.code : 'N/A'
                            });
                            alert('Erro ao reproduzir a música. Verifique se o arquivo existe e o formato é suportado (.mp3/.m4a/.webm).');
                        });
                    }
                } catch (error) {
                    console.error('Erro ao carregar faixa:', error);
                    alert('Erro ao carregar a música. Verifique se o arquivo está correto.');
                }
            }
        }

        let searchTimeout;
        const searchInput = document.getElementById('searchInput');
        const importYtBtn = document.getElementById('importYtBtn');

        function highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        function adjustFontSize() {
            const trackItems = document.querySelectorAll('.track-item');
            
            trackItems.forEach(item => {
                const title = item.querySelector('.track-title-small');
                const artist = item.querySelector('.artist-name-small');
                const container = item.querySelector('.track-info-small');
                
                if (title && artist && container) {
                    const containerWidth = container.offsetWidth;
                    const titleLength = title.textContent.length;
                    const artistLength = artist.textContent.length;
                    
                    // Ajusta o tamanho da fonte do título
                    if (titleLength > 30) {
                        title.style.fontSize = '0.85em';
                    } else if (titleLength > 20) {
                        title.style.fontSize = '0.9em';
                    } else {
                        title.style.fontSize = '1em';
                    }
                    
                    // Ajusta o tamanho da fonte do artista
                    if (artistLength > 25) {
                        artist.style.fontSize = '0.75em';
                    } else if (artistLength > 15) {
                        artist.style.fontSize = '0.8em';
                    } else {
                        artist.style.fontSize = '0.9em';
                    }
                }
            });
        }

        // Função para buscar metadados no Deezer (com detalhes de álbum e artista)
        async function searchDeezerMetadata(query) {
            try {
                const response = await fetch(`https://api.deezer.com/search?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                if (data.error) throw new Error(data.error.message);

                // Busca detalhes de álbum e artista para cada resultado
                const tracks = await Promise.all(data.data.slice(0, 5).map(async (track) => {
                    let albumData = {};
                    let artistData = {};
                    try {
                        const albumRes = await fetch(`https://api.deezer.com/album/${track.album.id}`);
                        albumData = await albumRes.json();
                    } catch {}
                    try {
                        const artistRes = await fetch(`https://api.deezer.com/artist/${track.artist.id}`);
                        artistData = await artistRes.json();
                    } catch {}
                    return {
                        title: track.title,
                        artist: track.artist.name,
                        artist_picture: artistData.picture_medium || '',
                        album: track.album.title,
                        album_cover: albumData.cover_xl || track.album.cover_medium,
                        release_date: albumData.release_date || '',
                        genres: albumData.genres && albumData.genres.data ? albumData.genres.data.map(g => g.name).join(', ') : '',
                        duration: formatDuration(track.duration),
                        cover: albumData.cover_medium || track.album.cover_medium,
                        file: track.preview,
                        trackNumber: playlist.length + 1,
                        source: 'deezer',
                        deezerId: track.id,
                        deezer_link: track.link
                    };
                }));
                return tracks;
            } catch (error) {
                console.error('Erro ao buscar metadados do Deezer:', error);
                return [];
            }
        }

        // Atualiza a função filterPlaylist para incluir busca no Deezer
        async function filterPlaylist(searchTerm) {
            if (!searchTerm) {
                updatePlaylistHTML();
                return;
            }

            const trackList = document.querySelector('.track-list');
            trackList.innerHTML = '<li class="loading">Buscando...</li>';

            try {
                // Busca músicas locais
                const localTracks = playlist.filter(track => 
                    track.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    track.artist.toLowerCase().includes(searchTerm.toLowerCase())
                );

                // Busca músicas no Deezer
                const deezerTracks = await searchDeezerMetadata(searchTerm);

                // Combina os resultados
                const allTracks = [...localTracks, ...deezerTracks];

                if (allTracks.length === 0) {
                    trackList.innerHTML = '<li class="no-results">Nenhuma música encontrada</li>';
                    return;
                }

                trackList.innerHTML = allTracks.map((track, index) => `
                    <li class="track-item ${playlist.indexOf(track) === currentTrack ? 'active' : ''}" 
                        onclick="playTrack(${playlist.indexOf(track)})">
                        <span class="track-number">${(index + 1).toString().padStart(2, '0')}</span>
                        <div class="track-info-small">
                            <div class="track-title-small">${highlightText(track.title, searchTerm)}</div>
                            <div class="artist-name-small">${highlightText(track.artist, searchTerm)}</div>
                            ${track.release_date ? `<div class='album-name-small'>${track.album} (${track.release_date})</div>` : `<div class='album-name-small'>${track.album}</div>`}
                            ${track.genres ? `<div class='genre-name-small'>${track.genres}</div>` : ''}
                        </div>
                        <span class="track-duration">${track.duration}</span>
                        ${track.source === 'deezer' ? 
                            `<img src='${track.album_cover}' alt='Capa' style='width:32px;height:32px;border-radius:4px;margin-right:8px;object-fit:cover;vertical-align:middle;'>` : ''}
                        ${track.source === 'deezer' ? 
                            '<button class="add-track" onclick="event.stopPropagation(); addDeezerTrack(' + JSON.stringify(track).replace(/"/g, '&quot;') + ')">+</button>' : 
                            '<button class="remove-track" onclick="event.stopPropagation(); removeTrack(' + playlist.indexOf(track) + ')">×</button>'}
                    </li>
                `).join('');

                adjustFontSize();
            } catch (error) {
                console.error('Erro ao filtrar playlist:', error);
                trackList.innerHTML = '<li class="error">Erro ao buscar músicas</li>';
            }
        }

        // Função para adicionar uma música do Deezer à playlist
        function addDeezerTrack(track) {
            playlist.push(track);
            sortPlaylist();
            updatePlaylistHTML();
            
            // Se for a primeira música, carrega ela
            if (playlist.length === 1) {
                currentTrack = 0;
                loadTrack();
            }
        }

        searchInput.addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterPlaylist(e.target.value);
            }, 300);
        });

        // Atualiza a função updatePlaylistHTML para usar o valor atual da busca
        function updatePlaylistHTML() {
            // Usa sistema de atualizações diferidas para não interromper reprodução
            deferredUIUpdates.scheduleUpdate(() => {
                if (window.__renderScheduled) return;
                window.__renderScheduled = true;
                requestAnimationFrame(() => {
                    window.__renderScheduled = false;
                const trackList = document.querySelector('.track-list');
                const clearButton = document.querySelector('.clear-playlist');
                const viewToggleBtn = document.getElementById('viewToggleBtn');
                if (viewToggleBtn && !viewToggleBtn.__bound) {
                    viewToggleBtn.addEventListener('click', () => {
                        const playerSection = document.querySelector('.player-section');
                        const icon = viewToggleBtn.querySelector('.material-symbols-rounded');
                        const isViewMode = playerSection.classList.toggle('view-mode');
                        icon.textContent = isViewMode ? 'fullscreen_exit' : 'fullscreen';
                    });
                    viewToggleBtn.__bound = true;
                }
                
                // Atualiza a lista de músicas
                trackList.innerHTML = playlist.map((track, index) => `
                    <li class="track-item ${index === currentTrack ? 'active' : ''}" 
                        onclick="playTrack(${index})">
                        <span class="track-number">${(index + 1).toString().padStart(2, '0')}</span>
                        <img src="${resolveCoverUrl(track.cover || 'musics/default-cover.jpg')}" loading="lazy" alt="capa" class="track-cover cover-loading" style="width:40px;height:40px;border-radius:6px;object-fit:cover;margin-right:8px;">
                        <div class="track-info-small">
                            <div class="track-title-small">${track.title}</div>
                            <div class="artist-name-small">${track.artist}</div>
                        </div>
                        <span class="track-duration">${track.duration}</span>
                        <button class="remove-track" onclick="event.stopPropagation(); removeTrack(${index})">×</button>
                    </li>
                `).join('');
                
                // Remove estado de loading das capas ao carregar/erro
                const covers = trackList.querySelectorAll('img.track-cover');
                covers.forEach(img => {
                    img.addEventListener('load', () => img.classList.remove('cover-loading'));
                    img.addEventListener('error', () => {
                        img.src = resolveCoverUrl('musics/default-cover.jpg');
                        img.classList.remove('cover-loading');
                    });
                });

                // Mostra ou esconde o botão de limpar playlist
                clearButton.style.display = playlist.length > 0 ? 'block' : 'none';
                
                // Aplica borda neon para cada card de música
                playlist.forEach((track, index) => {
                    const trackItem = trackList.children[index];
                    if (trackItem && track.cover && track.cover !== 'musics/default-cover.jpg') {
                        applyNeonBorder(trackItem, resolveCoverUrl(track.cover));
                    }
                });
                
                adjustFontSize();
                });
            }, 50); // Delay reduzido para responsividade
        }

        // Função para formatar a duração da música
        function formatDuration(duration) {
            const [minutes, seconds] = duration.split(':').map(Number);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Função para obter a duração real do arquivo de áudio
        function getAudioDuration(file) {
            return new Promise((resolve) => {
                const audio = new Audio(file);
                audio.addEventListener('loadedmetadata', () => {
                    const minutes = Math.floor(audio.duration / 60);
                    const seconds = Math.floor(audio.duration % 60);
                    resolve(`${minutes}:${seconds.toString().padStart(2, '0')}`);
                });
                audio.addEventListener('error', () => {
                    console.error(`Erro ao carregar áudio: ${file}`);
                    resolve('0:00');
                });
            });
        }

        // Função para atualizar as durações das músicas
        async function updateDurations() {
            for (let track of playlist) {
                if (track.duration === "0:00") {
                    try {
                        const duration = await getAudioDuration(track.file);
                        track.duration = duration;
                        console.log(`Duração atualizada para ${track.title}: ${duration}`);
                    } catch (error) {
                        console.error(`Erro ao obter duração de ${track.title}:`, error);
                    }
                }
            }
            sortPlaylist();
            updatePlaylistHTML();
        }

        // Função para ordenar a playlist
        function sortPlaylist() {
            playlist.sort((a, b) => {
                // Primeiro ordena por artista
                const artistCompare = a.artist.localeCompare(b.artist, 'pt-BR');
                if (artistCompare !== 0) return artistCompare;
                
                // Se for o mesmo artista, ordena por álbum
                const albumCompare = a.album.localeCompare(b.album, 'pt-BR');
                if (albumCompare !== 0) return albumCompare;
                
                // Se for o mesmo álbum, ordena por título
                return a.title.localeCompare(b.title, 'pt-BR');
            });

            // Atualiza os números das faixas
            playlist.forEach((track, index) => {
                track.trackNumber = index + 1;
            });

            updatePlaylistHTML();
            savePlaylistThrottled();
        }

        // Inicializa o player com as durações atualizadas
        updateDurations();
        updatePlaylistHTML();
        loadTrack();

        // Event Listeners
        document.querySelector('.progress-container').addEventListener('click', function(e) {
            const rect = this.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            audio.currentTime = pos * audio.duration;
        });

        document.querySelector('.volume-slider').addEventListener('input', function(e) {
            audio.volume = e.target.value / 100;
        });

        audio.addEventListener('timeupdate', function() {
            const progress = (audio.currentTime / audio.duration) * 100;
            document.querySelector('.progress-bar').style.width = progress + '%';
            document.querySelector('.current-time').textContent = formatTime(audio.currentTime);
        });

        audio.addEventListener('ended', function() {
            // Usa sistema de proteção para transições suaves
            if (repeatMode === 'one') {
                audio.currentTime = 0;
                audio.play();
            } else if (repeatMode === 'all') {
                // Agenda próxima faixa em segundo plano para não interromper
                backgroundTaskQueue.addTask(() => {
                    nextTrack();
                }, 'high');
            } else {
                if (currentTrack < playlist.length - 1) {
                    // Agenda próxima faixa em segundo plano para não interromper
                    backgroundTaskQueue.addTask(() => {
                        nextTrack();
                    }, 'high');
                }
            }
        });

        audio.addEventListener('error', function(e) {
            console.error('Erro no áudio:', e);
            const errorCode = audio.error ? audio.error.code : 'unknown';
            let errorMessage = 'Erro ao carregar a música.';
            
            switch(errorCode) {
                case 1:
                    errorMessage = 'Erro ao carregar a música. O arquivo pode estar corrompido.';
                    break;
                case 2:
                    errorMessage = 'Erro de rede. Verifique sua conexão com a internet.';
                    break;
                case 3:
                    errorMessage = 'Formato de arquivo não suportado. Use .mp3, .m4a ou .webm.';
                    break;
                case 4:
                    errorMessage = 'Arquivo de música não encontrado.';
                    break;
                default:
                    errorMessage = 'Erro ao carregar a música. Verifique se o arquivo existe.';
            }
            
            alert(errorMessage);
        });

        audio.addEventListener('loadeddata', function() {
            console.log('Áudio carregado com sucesso');
        });

        audio.addEventListener('loadstart', function() {
            console.log('Iniciando carregamento do áudio');
        });

        audio.addEventListener('canplay', function() {
            console.log('Áudio pronto para reprodução');
        });

        audio.addEventListener('canplaythrough', function() {
            console.log('Áudio totalmente carregado');
        });

        // Função para verificar se um arquivo de áudio é válido
        function validateAudioFile(file) {
            const validTypes = [
                'audio/mpeg',
                'audio/mp3',
                'audio/mp4',
                'audio/m4a',
                'audio/aac',
                'audio/ogg',
                'audio/opus',
                'audio/wav',
                'audio/flac',
                'audio/webm'
            ];
            
            const validExtensions = ['.mp3', '.m4a', '.aac', '.ogg', '.opus', '.wav', '.flac', '.webm'];
            
            // Verifica o tipo MIME
            if (file.type && !validTypes.includes(file.type)) {
                console.warn('Tipo MIME não suportado:', file.type);
            }
            
            // Verifica a extensão do arquivo
            const fileName = file.name || '';
            const extension = fileName.toLowerCase().substring(fileName.lastIndexOf('.'));
            if (!validExtensions.includes(extension)) {
                console.warn('Extensão de arquivo não suportada:', extension);
            }
            
            // Verifica o tamanho do arquivo (mínimo 1KB)
            if (file.size < 1024) {
                console.warn('Arquivo muito pequeno, pode estar corrompido:', file.size, 'bytes');
            }
            
            return true; // Sempre retorna true, mas loga os avisos
        }

        // Função para testar se um arquivo de áudio pode ser reproduzido
        function testAudioPlayability(blobUrl) {
            return new Promise((resolve, reject) => {
                const testAudio = new Audio();
                let timeout;
                
                const cleanup = () => {
                    clearTimeout(timeout);
                    testAudio.removeEventListener('canplaythrough', onSuccess);
                    testAudio.removeEventListener('error', onError);
                    testAudio.src = '';
                };
                
                const onSuccess = () => {
                    cleanup();
                    resolve(true);
                };
                
                const onError = (error) => {
                    cleanup();
                    console.error('Teste de reprodução falhou:', error);
                    reject(new Error('Arquivo não pode ser reproduzido'));
                };
                
                testAudio.addEventListener('canplaythrough', onSuccess);
                testAudio.addEventListener('error', onError);
                
                testAudio.src = blobUrl;
                testAudio.load();
                
                // Timeout de 10 segundos
                timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error('Timeout ao testar reprodução'));
                }, 10000);
            });
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            seconds = Math.floor(seconds % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function togglePlay() {
            const track = playlist[currentTrack];
            
            if (!track) {
                console.error('Nenhuma faixa selecionada para reproduzir');
                return;
            }
            
            // Ativa proteção de continuidade quando inicia reprodução
            if (!isPlaying) {
                musicContinuityProtection.activateProtection();
            }
            
            if (track.source === 'deezer') {
                // Para músicas do Deezer, recarrega o iframe com o novo estado de autoplay
                loadTrack();
            } else if (track.source === 'youtube') {
                // For YouTube Music, recarrega o iframe com o novo estado de autoplay
                loadTrack();
            } else {
                try {
                    if (isPlaying) {
                        audio.pause();
                        const icon = document.getElementById('playPauseIcon');
                        if (icon) icon.textContent = 'play_arrow';
                        // Desativa proteção quando pausa
                        musicContinuityProtection.deactivateProtection();
                    } else {
                        // Verifica se o áudio está pronto para reprodução
                        if (audio.readyState < 2) {
                            console.log('Áudio ainda não está pronto, aguardando...');
                            audio.addEventListener('canplay', function playWhenReady() {
                                audio.removeEventListener('canplay', playWhenReady);
                                audio.play().catch(error => {
                                    console.error('Erro ao reproduzir áudio:', error);
                                    alert('Erro ao reproduzir a música. Verifique se o arquivo existe.');
                                    musicContinuityProtection.deactivateProtection();
                                });
                            });
                        } else {
                            audio.play().catch(error => {
                                console.error('Erro ao reproduzir áudio:', error);
                                alert('Erro ao reproduzir a música. Verifique se o arquivo existe.');
                                musicContinuityProtection.deactivateProtection();
                            });
                        }
                        const icon = document.getElementById('playPauseIcon');
                        if (icon) icon.textContent = 'pause';
                    }
                } catch (error) {
                    console.error('Erro ao controlar reprodução:', error);
                    alert('Erro ao controlar a reprodução da música.');
                    musicContinuityProtection.deactivateProtection();
                }
            }
            isPlaying = !isPlaying;
        }

        // Função para processar URLs do Deezer
        async function processDeezerUrl(url) {
            try {
                // Extrai o ID do recurso da URL
                const resourceId = url.split('/').pop();
                let resourceType = 'track';
                if (url.includes('/album/')) resourceType = 'album';
                else if (url.includes('/playlist/')) resourceType = 'playlist';
                else if (url.includes('/artist/')) resourceType = 'artist';

                // Obtém dados detalhados do recurso
                const detailUrl = `https://api.deezer.com/${resourceType}/${resourceId}`;
                const detailResponse = await fetch(detailUrl);
                const detailData = await detailResponse.json();

                if (detailData.error) {
                    throw new Error(detailData.error);
                }

                if (resourceType === 'track') {
                    // Para uma única faixa
                    const trackInfo = {
                        title: detailData.title,
                        artist: detailData.artist.name,
                        album: detailData.album.title,
                        duration: formatDuration(detailData.duration),
                        cover: detailData.album.cover_medium,
                        file: url,
                        trackNumber: playlist.length + 1,
                        source: 'deezer',
                        deezerId: resourceId
                    };

                    playlist.push(trackInfo);
                } else if (resourceType === 'album') {
                    // Para um álbum inteiro
                    const tracks = detailData.tracks.data;
                    tracks.forEach((track, index) => {
                        const albumTrack = {
                            title: track.title,
                            artist: detailData.artist.name,
                            album: detailData.title,
                            duration: formatDuration(track.duration),
                            cover: detailData.cover_medium,
                            file: track.preview,
                            trackNumber: playlist.length + index + 1,
                            source: 'deezer',
                            deezerId: track.id
                        };
                        playlist.push(albumTrack);
                    });
                }

                sortPlaylist();
                updatePlaylistHTML();

                // Se for a primeira música, carrega ela
                if (playlist.length > 0 && currentTrack === 0) {
                    loadTrack();
                }

                return true;
            } catch (error) {
                console.error('Erro ao processar URL do Deezer:', error);
                alert('Erro ao processar o link do Deezer. Verifique se o link é válido.');
                return false;
            }
        }

        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function loadTrack() {
            const track = playlist[currentTrack];
            
            if (track.source === 'deezer') {
                // Para músicas do Deezer, carrega o player incorporado
                const playerContainer = document.querySelector('.player-container');
                const embedHtml = `
                    <div class="now-playing">
                        <img src="${resolveCoverUrl(track.cover)}" alt="${track.title}" class="album-cover">
                        <div class="track-info">
                            <h2 class="track-title">${track.title}</h2>
                            <p class="artist-name">${track.artist}</p>
                            <p class="album-name">${track.album}</p>
                        </div>
                    </div>
                    <div class="deezer-embed">
                        <iframe scrolling="no" frameborder="0" allowTransparency="true" 
                            src="https://www.deezer.com/plugins/player?format=classic&autoplay=${isPlaying ? 1 : 0}&playlist=true&width=700&height=350&color=007FEB&layout=dark&size=medium&type=tracks&id=${track.deezerId}&app_id=1"
                            width="700" height="350">
                        </iframe>
                    </div>
                `;
                playerContainer.innerHTML = embedHtml;
                // Para Deezer, esconde o loading após um pequeno delay
                setTimeout(() => {
                    hideLoading();
                }, 1000);
            } else if (track.source === 'youtube') {
                // For YouTube Music, create an embedded player
                const playerContainer = document.querySelector('.player-container');
                const embedHtml = `
                    <div class="now-playing">
                        <img src="${resolveCoverUrl(track.cover)}" alt="${track.title}" class="album-cover">
                        <div class="track-info">
                            <h2 class="track-title">${track.title}</h2>
                            <p class="artist-name">${track.artist}</p>
                        </div>
                    </div>
                    <div class="youtube-embed">
                        <iframe 
                            width="100%" 
                            height="350" 
                            src="https://www.youtube.com/embed/${track.youtubeId}?autoplay=${isPlaying ? 1 : 0}&enablejsapi=1" 
                            frameborder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            allowfullscreen>
                        </iframe>
                    </div>
                `;
                playerContainer.innerHTML = embedHtml;
                // Para YouTube, esconde o loading após um pequeno delay
                setTimeout(() => {
                    hideLoading();
                }, 1000);
            } else {
                // Para músicas locais, usa o player padrão
                audio.src = track.file;
                audio.load();
                updatePlayerInfo(track);
                
                // Adiciona event listeners para detectar quando a música está pronta
                const onCanPlay = () => {
                    hideLoading();
                    audio.removeEventListener('canplay', onCanPlay);
                    audio.removeEventListener('error', onError);
                };
                
                const onError = () => {
                    hideLoading();
                    audio.removeEventListener('canplay', onCanPlay);
                    audio.removeEventListener('error', onError);
                };
                
                audio.addEventListener('canplay', onCanPlay);
                audio.addEventListener('error', onError);
                
                if (isPlaying) {
                    audio.play().catch(error => {
                        console.error('Erro ao reproduzir áudio:', error);
                        alert('Erro ao reproduzir a música. Verifique se o arquivo existe e o formato é suportado (.mp3/.m4a/.webm).');
                        hideLoading();
                    });
                }
            }
        }

        // Função para verificar se uma URL é do Deezer
        function isDeezerUrl(url) {
            const deezerPatterns = [
                /^https?:\/\/(?:www\.)?deezer\.com\/(?:album|episode|playlist|show|track)\/\d+/,
                /^https?:\/\/deezer\.page\.link\/.+/
            ];
            return deezerPatterns.some(pattern => pattern.test(url));
        }

        // Função para buscar a capa do álbum no Deezer
        async function fetchDeezerCover(title, artist) {
            try {
                const query = `${artist} ${title}`;
                const response = await fetch(`https://api.deezer.com/search?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                if (data && data.data && data.data.length > 0) {
                    const track = data.data[0];
                    return track.album.cover_xl || track.album.cover_medium || track.album.cover;
                }
            } catch (error) {
                console.error('Erro ao buscar capa do Deezer:', error);
            }
            return 'musics/default-cover.jpg';
        }

        // Atualiza a função handleFileUpload para incluir suporte a URLs do Deezer
        async function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            for (const file of files) {
                if (!file.type.startsWith('audio/')) continue;

                try {
                    // Lê os metadados ID3
                    let title = "";
                    let artist = "";
                    let album = "";
                    let cover = "";

                    await new Promise((resolve) => {
                        window.jsmediatags.read(file, {
                            onSuccess: function(tag) {
                                title = tag.tags.title || "";
                                artist = tag.tags.artist || "";
                                album = tag.tags.album || "";
                                if (tag.tags.picture) {
                                    const { data, format } = tag.tags.picture;
                                    let base64String = "";
                                    for (let i = 0; i < data.length; i++) {
                                        base64String += String.fromCharCode(data[i]);
                                    }
                                    cover = `data:${format};base64,${btoa(base64String)}`;
                                }
                                resolve();
                            },
                            onError: function() {
                                resolve();
                            }
                        });
                    });

                    // Se não achou, tenta extrair do nome do arquivo
                    if (!title || !artist) {
                        let name = file.name.replace(/\.[^/.]+$/, "");
                        if (name.includes(" - ")) {
                            const parts = name.split(" - ");
                            if (parts.length >= 2) {
                                artist = artist || parts[0].trim();
                                title = title || parts[1].trim();
                            }
                        } else {
                            title = title || name;
                        }
                    }

                    // Se não achou capa, busca no Deezer
                    if (!cover) {
                        cover = await fetchDeezerCover(title, artist);
                    }

                    // Cria o objeto da música
                    const arrayBuffer = await file.arrayBuffer();
                    const music = {
                        title: title || "Desconhecido",
                        artist: artist || "Desconhecido",
                        album: album || "Desconhecido",
                        duration: "0:00",
                        cover: cover,
                        file: arrayBuffer,
                        fileType: file.type,
                        fileName: file.name,
                        trackNumber: playlist.length + 1
                    };

                    // Salva no banco de dados
                    const id = await saveMusicToDB(music);
                    music.id = id;

                    // Cria URL do blob para reprodução
                    const blob = new Blob([arrayBuffer], { type: file.type });
                    music.file = URL.createObjectURL(blob);

                    // Adiciona à playlist
                    playlist.push(music);

                    // Atualiza a duração
                    const audio = new Audio(music.file);
                    audio.addEventListener('loadedmetadata', () => {
                        const minutes = Math.floor(audio.duration / 60);
                        const seconds = Math.floor(audio.duration % 60);
                        music.duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        sortPlaylist();
                        updatePlaylistHTML();
                    });

                    if (playlist.length === 1) {
                        currentTrack = 0;
                        loadTrack();
                    }
                } catch (error) {
                    console.error('Erro ao processar arquivo:', error);
                    alert(`Erro ao processar o arquivo ${file.name}`);
                }
            }

            event.target.value = '';
        }

        // Variáveis para controle de performance
        let lastCheckTime = 0;
        let isUpdating = false;
        let updateQueue = [];

        // Função otimizada para verificar mudanças com proteção de continuidade
        async function checkMusicChanges() {
            if (isUpdating) return;
            
            // Se está tocando música, agenda para depois
            if (isPlaying) {
                console.log('🎵 Música tocando, agendando verificação de mudanças para depois');
                backgroundTaskQueue.addTask(checkMusicChanges, 'low');
                return;
            }
            
            try {
                const url = currentPlaylist 
                    ? `http://localhost:5000/check_music_changes?playlist=${encodeURIComponent(currentPlaylist)}&last_check=${lastCheckTime}`
                    : `http://localhost:5000/check_music_changes?last_check=${lastCheckTime}`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                if (data.changes && data.changes.length > 0) {
                    console.log(`${data.changes.length} mudanças detectadas`);
                    // Processa mudanças em segundo plano para não interromper reprodução
                    backgroundTaskQueue.addTask(async () => {
                        await processMusicChanges(data.changes);
                    }, 'normal');
                }
                
                lastCheckTime = data.current_time || Date.now() / 1000;
            } catch (error) {
                console.error('Erro ao verificar mudanças:', error);
            }
        }

        // Função para processar mudanças de forma otimizada
        async function processMusicChanges(changes) {
            if (isUpdating) {
                updateQueue.push(...changes);
                return;
            }
            
            isUpdating = true;
            
            try {
                // Agrupa mudanças por tipo
                const newFiles = changes.filter(c => c.action === 'modified' && !playlist.some(track => track.fileName === c.name));
                const deletedFiles = changes.filter(c => c.action === 'deleted');
                
                // Remove arquivos deletados
                if (deletedFiles.length > 0) {
                    for (const deleted of deletedFiles) {
                        const index = playlist.findIndex(track => track.fileName === deleted.name);
                        if (index !== -1) {
                            playlist.splice(index, 1);
                        }
                    }
                }
                
                // Processa novos arquivos em lotes
                if (newFiles.length > 0) {
                    await processNewFiles(newFiles);
                }
                
                // Processa fila de atualizações pendentes
                while (updateQueue.length > 0) {
                    const queuedChanges = updateQueue.splice(0);
                    await processMusicChanges(queuedChanges);
                }
                
                // Atualiza interface apenas se houve mudanças
                if (newFiles.length > 0 || deletedFiles.length > 0) {
                    await dedupePlaylistAndDB();
                    sortPlaylist();
                    updatePlaylistHTML();
                    updateDurations();
                }
                
            } finally {
                isUpdating = false;
            }
        }

        // Função otimizada para processar novos arquivos
        async function processNewFiles(newFiles) {
            const batchSize = 5; // Processa 5 arquivos por vez
            
            for (let i = 0; i < newFiles.length; i += batchSize) {
                const batch = newFiles.slice(i, i + batchSize);
                const promises = batch.map(music => processSingleFile(music));
                
                await Promise.allSettled(promises);
                
                // Pequena pausa entre lotes para não travar a interface
                if (i + batchSize < newFiles.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
        }

        // Função para processar um único arquivo
        async function processSingleFile(music) {
            try {
                // Verifica se já existe no IndexedDB
                const existing = await getMusicByFileName(music.name);
                if (existing) {
                    // Verifica se precisa atualizar metadados
                    const needsUpdate = shouldUpdateMetadata(existing, music);
                    if (needsUpdate) {
                        const updated = { ...existing };
                        updateMetadataFromServer(updated, music);
                        await updateMusicInDB(updated);
                    }
                    
                    const url = arrayBufferToBlobUrl(existing.file, existing.fileType);
                    playlist.push({ ...existing, file: url });
                    return;
                }

                // Baixa o arquivo apenas se não existe no DB
                await downloadAndProcessFile(music);
                
            } catch (e) {
                console.error('Falha ao processar arquivo:', music.name, e);
            }
        }

        // Função para verificar se precisa atualizar metadados
        function shouldUpdateMetadata(existing, serverData) {
            const isUnknown = (v) => !v || /desconhecid/i.test(String(v));
            return (
                (serverData.title && isUnknown(existing.title)) ||
                (serverData.artist && isUnknown(existing.artist)) ||
                (serverData.album && isUnknown(existing.album)) ||
                (serverData.year && isUnknown(existing.year)) ||
                (serverData.cover && (isUnknown(existing.cover) || /default-cover\.jpg$/.test(existing.cover || '')))
            );
        }

        // Função para atualizar metadados do servidor
        function updateMetadataFromServer(existing, serverData) {
            const isUnknown = (v) => !v || /desconhecid/i.test(String(v));
            
            if (serverData.title && isUnknown(existing.title)) {
                existing.title = serverData.title;
            }
            if (serverData.artist && isUnknown(existing.artist)) {
                existing.artist = serverData.artist;
            }
            if (serverData.album && isUnknown(existing.album)) {
                existing.album = serverData.album;
            }
            if (serverData.year && isUnknown(existing.year)) {
                existing.year = String(serverData.year);
            }
            if (serverData.cover && (isUnknown(existing.cover) || /default-cover\.jpg$/.test(existing.cover || ''))) {
                existing.cover = serverData.cover;
            }
        }

        // Função para baixar e processar arquivo
        async function downloadAndProcessFile(music) {
            // Primeiro, obtém metadados completos do servidor
            const metadataUrl = currentPlaylist 
                ? `http://localhost:5000/list_music?playlist=${encodeURIComponent(currentPlaylist)}&skip_metadata=false`
                : 'http://localhost:5000/list_music?skip_metadata=false';
            
            const metadataResponse = await fetch(metadataUrl);
            const metadataData = await metadataResponse.json();
            const fullMetadata = metadataData.music.find(m => m.name === music.name);
            
            if (!fullMetadata) return;
            
            // Baixa o arquivo
            const fileUrl = `http://localhost:5000${music.path}`;
            const fileResp = await fetch(fileUrl);
            const mimeType = fileResp.headers.get('content-type') || 'audio/mpeg';
            const arrayBuffer = await fileResp.arrayBuffer();

            // Usa metadados do servidor
            const baseName = music.name.replace(/\.[^/.]+$/, "");
            const artist = (fullMetadata.artist && fullMetadata.artist.trim()) || "Artista Desconhecido";
            const album = (fullMetadata.album && fullMetadata.album.trim()) || "Álbum Desconhecido";
            const title = (fullMetadata.title && fullMetadata.title.trim()) || baseName;
            const coverUrl = fullMetadata.cover || "musics/default-cover.jpg";

            const musicRecord = {
                title: title,
                artist: artist,
                album: album,
                duration: "0:00",
                cover: coverUrl,
                file: arrayBuffer,
                fileType: mimeType,
                fileName: music.name,
                trackNumber: playlist.length + 1,
                year: (fullMetadata.year && String(fullMetadata.year)) || '',
                playlist: fullMetadata.playlist || 'Geral'
            };

            const id = await saveMusicToDB(musicRecord);
            musicRecord.id = id;

            const blobUrl = arrayBufferToBlobUrl(arrayBuffer, mimeType);
            playlist.push({ ...musicRecord, file: blobUrl });
        }

        // Função para atualizar a lista de músicas (mantida para compatibilidade)
        async function updateMusicList() {
            console.log('🔄 [PRIORIDADE 4] Atualização manual solicitada');
            
            // Se está tocando música, agenda para depois
            if (isPlaying) {
                console.log('🎵 Música tocando, agendando atualização para depois');
                backgroundTaskQueue.addTask(updateMusicList, 'normal');
                return;
            }
            
            await checkMusicChanges();
        }
        
        // Função para carregar todas as playlists com barra de progresso
        async function loadAllPlaylistsWithProgress() {
            if (!downloadProgress.isActive || allPlaylists.length === 0) {
                console.log('Barra de progresso não está ativa ou não há playlists');
                return;
            }
            
            console.log('🔄 [PRIORIDADE 4] Carregando todas as playlists com progresso...');
            
            // Carrega cada playlist sequencialmente
            for (const playlist of allPlaylists) {
                try {
                    await loadPlaylist(playlist.name);
                    // Pequena pausa entre playlists
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    console.error(`Erro ao carregar playlist ${playlist.name}:`, error);
                }
            }
            
            console.log('✅ [PRIORIDADE 4] Todas as playlists carregadas');
        }
        
        // Função para iniciar carregamento automático de todas as playlists
        function startAutoLoadAllPlaylists() {
            if (allPlaylists.length > 0) {
                // Mostra a barra de progresso
                showDownloadProgress();
                updateProgressUI();
                
                // Configura callback para quando terminar
                downloadProgress.onComplete = () => {
                    console.log('🎉 Carregamento automático de todas as playlists concluído!');
                    // Aqui você pode adicionar ações adicionais após o carregamento
                };
                
                // Inicia o carregamento
                loadAllPlaylistsWithProgress();
            }
        }

        // Atualiza a lista de músicas a cada 10 segundos (reduzido de 5 para 10)
        setInterval(checkMusicChanges, 10000);

        // Função para tocar uma música específica
        function playTrack(index) {
            currentTrack = index;
            loadTrack();
            if (!isPlaying) {
                togglePlay();
            }
        }

        // Inicializa o player
        updateMusicList();
        updatePlaylistHTML();

        function toggleRepeat() {
            const repeatButton = document.getElementById('repeatButton');
            const repeatIcon = document.getElementById('repeatIcon');
            switch (repeatMode) {
                case 'none':
                    repeatMode = 'one';
                    repeatButton.classList.add('active');
                    if (repeatIcon) repeatIcon.textContent = 'repeat_one';
                    break;
                case 'one':
                    repeatMode = 'all';
                    repeatButton.classList.add('active');
                    if (repeatIcon) repeatIcon.textContent = 'repeat';
                    break;
                case 'all':
                    repeatMode = 'none';
                    repeatButton.classList.remove('active');
                    if (repeatIcon) repeatIcon.textContent = 'repeat';
                    break;
            }
        }

        // Adiciona o evento de redimensionamento
        window.addEventListener('resize', adjustFontSize);

        // Função para salvar a playlist no localStorage
        function savePlaylist() {
            const playlistData = playlist.map(track => ({
                ...track,
                file: track.file // Salva a URL do arquivo
            }));
            localStorage.setItem('musickeraPlaylist', JSON.stringify(playlistData));
        }

        // Salva a playlist com limitação de frequência para evitar excesso de gravações
        let __saveScheduled = false;
        function savePlaylistThrottled() {
            if (__saveScheduled) return;
            __saveScheduled = true;
            setTimeout(() => {
                __saveScheduled = false;
                try {
                    savePlaylist();
                } catch (e) {
                    console.error('Falha ao salvar playlist:', e);
                }
            }, 500);
        }

        // Função para carregar a playlist do localStorage
        function loadPlaylist() {
            const savedPlaylist = localStorage.getItem('musickeraPlaylist');
            if (savedPlaylist) {
                const parsedPlaylist = JSON.parse(savedPlaylist);
                playlist.length = 0; // Limpa a playlist atual
                parsedPlaylist.forEach(track => {
                    playlist.push(track);
                });
                updatePlaylistHTML();
                if (playlist.length > 0) {
                    currentTrack = 0;
                    loadTrack();
                }
            }
        }

        // Função para remover uma música da playlist
        async function removeTrack(index) {
            if (index === currentTrack) {
                // Se estiver removendo a música atual, para a reprodução
                audio.pause();
                isPlaying = false;
            }
            
            const track = playlist[index];
            if (track.id) {
                try {
                    await removeMusicFromDB(track.id);
                } catch (error) {
                    console.error('Erro ao remover música do banco de dados:', error);
                }
            }
            
            playlist.splice(index, 1);
            
            if (currentTrack >= index && currentTrack > 0) {
                currentTrack--;
            }
            
            sortPlaylist();
            updatePlaylistHTML();
            
            if (playlist.length > 0) {
                loadTrack();
            } else {
                document.querySelector('.track-title').textContent = "Nenhuma música";
                document.querySelector('.artist-name').textContent = "";
                document.querySelector('.album-name').textContent = "";
                document.querySelector('.album-cover').src = resolveCoverUrl('musics/default-cover.jpg');
                document.querySelector('.progress-bar').style.width = "0%";
                document.querySelector('.current-time').textContent = "0:00";
                document.querySelector('.duration').textContent = "0:00";
            }
        }

        // Função para limpar toda a playlist
        async function clearPlaylist() {
            if (confirm("Tem certeza que deseja limpar toda a playlist?")) {
                try {
                    await clearMusicDB();
                    
                    audio.pause();
                    isPlaying = false;
                    
                    playlist.length = 0;
                    currentTrack = 0;
                    
                    updatePlaylistHTML();
                    
                    document.querySelector('.track-title').textContent = "Nenhuma música";
                    document.querySelector('.artist-name').textContent = "";
                    document.querySelector('.album-name').textContent = "";
                    document.querySelector('.album-cover').src = resolveCoverUrl('musics/default-cover.jpg');
                    document.querySelector('.progress-bar').style.width = "0%";
                    document.querySelector('.current-time').textContent = "0:00";
                    document.querySelector('.duration').textContent = "0:00";
                } catch (error) {
                    console.error('Erro ao limpar banco de dados:', error);
                    alert('Erro ao limpar a playlist');
                }
            }
        }

        // Função otimizada para carregar a playlist do banco de dados ao iniciar
        async function loadPlaylistFromDB() {
            try {
                console.log('🔄 [PRIORIDADE 1] Carregando playlist do banco de dados...');
                const musics = await loadMusicsFromDB();
                playlist.length = 0;
                
                // Processa músicas em lotes para melhor performance
                const batchSize = 20;
                for (let i = 0; i < musics.length; i += batchSize) {
                    const batch = musics.slice(i, i + batchSize);
                    
                    for (const music of batch) {
                        // Adia a criação de Blob URL para o momento da reprodução
                        music.fileArrayBuffer = music.file;
                        delete music.file;
                        playlist.push(music);
                    }
                    
                    // Pequena pausa entre lotes para não travar a interface
                    if (i + batchSize < musics.length) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
                
                console.log(`✅ [PRIORIDADE 1] Carregadas ${playlist.length} músicas do banco de dados`);
                
                await dedupePlaylistAndDB();
                updatePlaylistHTML();
                if (playlist.length > 0) {
                    currentTrack = 0;
                    loadTrack();
                } else {
                    // Se não há músicas, esconde o loading
                    hideLoading();
                }
            } catch (error) {
                console.error('Erro ao carregar playlist do banco de dados:', error);
                hideLoading(); // Hide loading on error
            }
        }

        // ===== SISTEMA DE INICIALIZAÇÃO COM HIERARQUIA DE PRIORIDADES =====
        
        // Função principal de inicialização otimizada
        async function initializePlayerWithPriorities() {
            console.log('🚀 Iniciando player com hierarquia otimizada...');
            showLoading();
            
            try {
                // PRIORIDADE 1: Funções críticas (sequencial) - MÚSICA PRIMEIRO
                console.log('📋 Executando PRIORIDADE 1: Funções críticas para reprodução');
                await initDB();
                await loadPlaylistFromDB();
                
                // Se há música, carrega imediatamente para reprodução
                if (playlist.length > 0) {
                    currentTrack = 0;
                    loadTrack();
                    console.log('🎵 Música carregada e pronta para reprodução');
                } else {
                    hideLoading();
                }
                
                // PRIORIDADE 2: Funções em segundo plano (não bloqueiam reprodução)
                console.log('📋 Agendando PRIORIDADE 2: Tarefas em segundo plano');
                backgroundTaskQueue.addTask(async () => {
                    await loadPlaylists();
                }, 'normal');
                
                backgroundTaskQueue.addTask(async () => {
                    await initialChangeCheck();
                }, 'normal');
                
                // PRIORIDADE 3: Sistema de manutenção (em segundo plano)
                console.log('📋 Configurando PRIORIDADE 3: Sistema de manutenção em segundo plano');
                backgroundTaskQueue.addTask(async () => {
                    setInterval(() => {
                        // Só verifica mudanças se não estiver tocando música
                        if (!isPlaying) {
                            checkMusicChanges();
                        } else {
                            // Se estiver tocando, agenda para depois
                            backgroundTaskQueue.addTask(checkMusicChanges, 'low');
                        }
                    }, 15000); // Aumentado para 15s para reduzir interferência
                }, 'low');
                
                console.log('✅ Player inicializado com sucesso! Música protegida contra interrupções.');
                
            } catch (error) {
                console.error('❌ Erro na inicialização do player:', error);
                hideLoading();
            }
        }
        
        // Função para verificação inicial de mudanças
        async function initialChangeCheck() {
            try {
                console.log('🔄 [PRIORIDADE 2] Verificando mudanças iniciais...');
                await checkMusicChanges();
                console.log('✅ [PRIORIDADE 2] Verificação inicial concluída');
            } catch (error) {
                console.error('❌ [PRIORIDADE 2] Erro na verificação inicial:', error);
            }
        }
        
        // ===== SISTEMA DE BARRA DE PROGRESSO DE DOWNLOAD =====
        
        // Variáveis para controle da barra de progresso
        let downloadProgress = {
            isActive: false,
            totalPlaylists: 0,
            processedPlaylists: 0,
            totalFiles: 0,
            processedFiles: 0,
            playlists: new Map(), // Map para armazenar progresso de cada playlist
            onComplete: null
        };
        
        // Função para mostrar a barra de progresso
        function showDownloadProgress() {
            const progressBar = document.getElementById('downloadProgressBar');
            progressBar.style.display = 'block';
            downloadProgress.isActive = true;
            
            // Adiciona evento para fechar
            document.getElementById('closeProgressBar').onclick = hideDownloadProgress;
        }
        
        // Função para esconder a barra de progresso
        function hideDownloadProgress() {
            const progressBar = document.getElementById('downloadProgressBar');
            progressBar.style.display = 'none';
            downloadProgress.isActive = false;
            hideLoading(); // Hide loading animation when download progress is hidden
        }
        
        // Função para inicializar o progresso de download
        function initDownloadProgress(playlists) {
            downloadProgress.totalPlaylists = playlists.length;
            downloadProgress.processedPlaylists = 0;
            downloadProgress.totalFiles = 0;
            downloadProgress.processedFiles = 0;
            downloadProgress.playlists.clear();
            
            // Inicializa o progresso de cada playlist
            playlists.forEach(playlist => {
                downloadProgress.playlists.set(playlist.name, {
                    name: playlist.name,
                    status: 'pending',
                    progress: 0,
                    totalFiles: playlist.music_count || 0,
                    processedFiles: 0,
                    error: null
                });
                downloadProgress.totalFiles += playlist.music_count || 0;
            });
            
            updateProgressUI();
            showDownloadProgress();
        }
        
        // Função para atualizar o progresso de uma playlist específica
        function updatePlaylistProgress(playlistName, progress, status, processedFiles = null, error = null) {
            const playlist = downloadProgress.playlists.get(playlistName);
            if (playlist) {
                playlist.progress = progress;
                playlist.status = status;
                if (processedFiles !== null) {
                    playlist.processedFiles = processedFiles;
                }
                if (error) {
                    playlist.error = error;
                }
                
                updateProgressUI();
            }
        }
        
        // Função para atualizar a interface de progresso
        function updateProgressUI() {
            if (!downloadProgress.isActive) return;
            
            // Calcula progresso geral
            const overallProgress = downloadProgress.totalPlaylists > 0 
                ? (downloadProgress.processedPlaylists / downloadProgress.totalPlaylists) * 100 
                : 0;
            
            // Atualiza barra de progresso geral
            const overallBar = document.getElementById('overallProgressBar');
            const overallText = document.getElementById('overallProgressText');
            overallBar.style.width = `${overallProgress}%`;
            overallText.textContent = `${Math.round(overallProgress)}%`;
            
            // Atualiza estatísticas
            const processedFilesEl = document.getElementById('processedFiles');
            const totalFilesEl = document.getElementById('totalFiles');
            processedFilesEl.textContent = downloadProgress.processedFiles;
            totalFilesEl.textContent = downloadProgress.totalFiles;
            
            // Atualiza lista de playlists
            updatePlaylistProgressList();
            
            // Atualiza status
            updateDownloadStatus();
        }
        
        // Função para atualizar a lista de progresso das playlists
        function updatePlaylistProgressList() {
            const playlistList = document.getElementById('playlistProgressList');
            playlistList.innerHTML = '';
            
            downloadProgress.playlists.forEach(playlist => {
                const playlistItem = document.createElement('div');
                playlistItem.className = `playlist-progress-item ${playlist.status}`;
                
                const statusText = getStatusText(playlist.status);
                const progressPercent = Math.round(playlist.progress);
                
                playlistItem.innerHTML = `
                    <div class="playlist-name">${playlist.name}</div>
                    <div class="playlist-status">${statusText}</div>
                    <div class="playlist-progress-bar">
                        <div class="playlist-progress-fill" style="width: ${playlist.progress}%"></div>
                    </div>
                    <div class="playlist-progress-text">${playlist.processedFiles}/${playlist.totalFiles} arquivos (${progressPercent}%)</div>
                `;
                
                playlistList.appendChild(playlistItem);
            });
        }
        
        // Função para obter texto de status
        function getStatusText(status) {
            switch (status) {
                case 'pending': return '⏳ Aguardando...';
                case 'processing': return '🔄 Processando...';
                case 'completed': return '✅ Concluído';
                case 'error': return '❌ Erro';
                default: return '⏳ Aguardando...';
            }
        }
        
        // Função para atualizar status geral
        function updateDownloadStatus() {
            const statusEl = document.getElementById('downloadStatus');
            
            if (downloadProgress.processedPlaylists === downloadProgress.totalPlaylists) {
                statusEl.textContent = '🎉 Carregamento concluído!';
                statusEl.style.color = '#1DB954';
                
                // Auto-fecha após 3 segundos
                setTimeout(() => {
                    if (downloadProgress.isActive) {
                        hideDownloadProgress();
                        if (downloadProgress.onComplete) {
                            downloadProgress.onComplete();
                        }
                    }
                }, 3000);
            } else if (downloadProgress.processedPlaylists > 0) {
                statusEl.textContent = `🔄 Processando... ${downloadProgress.processedPlaylists}/${downloadProgress.totalPlaylists} playlists`;
            } else {
                statusEl.textContent = '⏳ Iniciando carregamento...';
            }
        }
        
        // Função para marcar playlist como concluída
        function completePlaylist(playlistName) {
            const playlist = downloadProgress.playlists.get(playlistName);
            if (playlist) {
                playlist.status = 'completed';
                playlist.progress = 100;
                playlist.processedFiles = playlist.totalFiles;
                downloadProgress.processedPlaylists++;
                downloadProgress.processedFiles += playlist.totalFiles;
                
                updateProgressUI();
            }
        }
        
        // Função para marcar playlist com erro
        function errorPlaylist(playlistName, error) {
            const playlist = downloadProgress.playlists.get(playlistName);
            if (playlist) {
                playlist.status = 'error';
                playlist.error = error;
                downloadProgress.processedPlaylists++;
                
                updateProgressUI();
            }
        }
        
        // Função para atualizar progresso de arquivos de uma playlist
        function updatePlaylistFileProgress(playlistName, processedFiles) {
            const playlist = downloadProgress.playlists.get(playlistName);
            if (playlist) {
                playlist.processedFiles = processedFiles;
                playlist.progress = playlist.totalFiles > 0 
                    ? (processedFiles / playlist.totalFiles) * 100 
                    : 0;
                
                updateProgressUI();
            }
        }
        
        // Inicializa o player com hierarquia de prioridades
        initializePlayerWithPriorities();

        const platformSelector = document.getElementById('platformSelector');
        const searchResults = document.getElementById('searchResults');

        // Function to search on different platforms
        async function searchPlatform(query, platform) {
            if (!query) {
                searchResults.style.display = 'none';
                return;
            }

            searchResults.innerHTML = '<div class="search-loading">Buscando...</div>';
            searchResults.style.display = 'block';
            showLoading(); // Show loading animation during search

            try {
                let results = [];
                
                if (platform === 'deezer') {
                    // Search Deezer API
                    const response = await fetch(`https://api.deezer.com/search?q=${encodeURIComponent(query)}`);
                    const data = await response.json();
                    
                    if (data.error) throw new Error(data.error.message);
                    
                    results = data.data.map(track => ({
                        id: track.id,
                        title: track.title,
                        artist: track.artist.name,
                        cover: track.album.cover_medium,
                        platform: 'Deezer',
                        type: 'track',
                        url: track.link
                    }));
                } else if (platform === 'youtube') {
                    // Search YouTube Music
                    const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)} music&type=video&videoCategoryId=10&maxResults=10&key=YOUR_API_KEY`);
                    const data = await response.json();
                    
                    if (data.error) throw new Error(data.error.message);
                    
                    results = data.items.map(item => ({
                        id: item.id.videoId,
                        title: item.snippet.title.replace(/\(Official Music Video\)|\[Official Music Video\]|\(Official Video\)|\[Official Video\]/gi, '').trim(),
                        artist: item.snippet.channelTitle.replace(' - Topic', ''),
                        cover: item.snippet.thumbnails.high.url,
                        platform: 'YouTube Music',
                        type: 'video',
                        url: `https://www.youtube.com/watch?v=${item.id.videoId}`
                    }));
                } else if (platform === 'suamusica') {
                    // Placeholder for Sua Música API integration
                    results = [];
                }

                displaySearchResults(results);
            } catch (error) {
                console.error('Erro na busca:', error);
                searchResults.innerHTML = '<div class="search-error">Erro ao buscar resultados</div>';
            } finally {
                hideLoading(); // Hide loading animation after search completes
            }
        }

        // Function to display search results
        function displaySearchResults(results) {
            if (results.length === 0) {
                searchResults.innerHTML = '<div class="search-loading">Nenhum resultado encontrado</div>';
                return;
            }

            searchResults.innerHTML = results.map(result => `
                <div class="search-result-item" data-id="${result.id}" onclick="importTrack('${result.platform.toLowerCase()}', '${result.id}')">
                    <img src="${result.cover}" alt="${result.title}" class="search-result-cover">
                    <div class="search-result-info">
                        <div class="search-result-title">${result.title}</div>
                        <div class="search-result-artist">${result.artist}</div>
                    </div>
                    <span class="search-result-platform">${result.platform}</span>
                    <button class="import-button">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="12" y1="5" x2="12" y2="19"></line>
                            <line x1="5" y1="12" x2="19" y2="12"></line>
                        </svg>
                        Importar
                    </button>
                </div>
            `).join('');
        }

        // Function to import a track
        async function importTrack(platform, id) {
            try {
                if (platform === 'deezer') {
                    const response = await fetch(`https://api.deezer.com/track/${id}`);
                    const track = await response.json();
                    
                    if (track.error) throw new Error(track.error.message);

                    const newTrack = {
                        title: track.title,
                        artist: track.artist.name,
                        album: track.album.title,
                        duration: formatDuration(track.duration),
                        cover: track.album.cover_medium,
                        file: track.preview,
                        trackNumber: playlist.length + 1,
                        source: 'deezer',
                        deezerId: track.id
                    };

                    playlist.push(newTrack);
                    sortPlaylist();
                    updatePlaylistHTML();
                    
                    if (playlist.length === 1) {
                        currentTrack = 0;
                        loadTrack();
                    }
                } else if (platform === 'youtube') {
                    // For YouTube Music, we'll use the video ID to create an embedded player
                    const newTrack = {
                        title: document.querySelector(`[data-id="${id}"] .search-result-title`).textContent,
                        artist: document.querySelector(`[data-id="${id}"] .search-result-artist`).textContent,
                        cover: document.querySelector(`[data-id="${id}"] .search-result-cover`).src,
                        trackNumber: playlist.length + 1,
                        source: 'youtube',
                        youtubeId: id,
                        file: `https://www.youtube.com/watch?v=${id}`
                    };

                    playlist.push(newTrack);
                    sortPlaylist();
                    updatePlaylistHTML();
                    
                    if (playlist.length === 1) {
                        currentTrack = 0;
                        loadTrack();
                    }
                }

                searchResults.style.display = 'none';
            } catch (error) {
                console.error('Erro ao importar música:', error);
                alert('Erro ao importar a música');
            }
        }

        // Update search input event listener
        searchInput.addEventListener('input', function(e) {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                const platform = platformSelector.value;
                searchPlatform(e.target.value, platform);
            }, 300);
        });

        // Close search results when clicking outside
        document.addEventListener('click', function(e) {
            if (!searchResults.contains(e.target) && e.target !== searchInput) {
                searchResults.style.display = 'none';
            }
        });

        // Update platform selector event listener
        platformSelector.addEventListener('change', function() {
            if (searchInput.value) {
                searchPlatform(searchInput.value, this.value);
            }
        });

        // Import YouTube Music playlist with folder selection
        importYtBtn.addEventListener('click', async function() {
            // Solicita a URL da playlist
            const url = prompt('Cole o link da playlist do YouTube Music ou vídeo único:');
            if (!url) return;
            
            try {
                importYtBtn.disabled = true;
                showLoading(); // Show loading animation
                
                // Primeiro, extrai o nome da playlist
                const extractResp = await fetch('http://localhost:5000/extract_playlist_name', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url })
                });
                
                const extractData = await extractResp.json().catch(() => ({}));
                if (!extractResp.ok || extractData.error) {
                    alert('Erro ao extrair informações da playlist: ' + (extractData.error || 'Erro desconhecido'));
                    return;
                }
                
                const extractedName = extractData.playlist_name;
                
                // Pergunta se quer usar o nome extraído ou escolher uma pasta existente
                const useExtractedName = confirm(
                    `Nome da playlist extraído: "${extractedName}"\n\n` +
                    `Clique em "OK" para usar este nome e criar uma nova pasta.\n` +
                    `Clique em "Cancelar" para escolher uma pasta existente.`
                );
                
                let finalPlaylistName;
                
                if (useExtractedName) {
                    // Usa o nome extraído
                    finalPlaylistName = extractedName;
                } else {
                    // Lista as pastas existentes para escolha
                    const existingPlaylists = await getExistingPlaylists();
                    
                    if (existingPlaylists.length === 0) {
                        alert('Nenhuma pasta existente encontrada. Usando o nome extraído da playlist.');
                        finalPlaylistName = extractedName;
                    } else {
                        const playlistList = existingPlaylists.map((name, index) => `${index + 1}. ${name}`).join('\n');
                        const choice = prompt(
                            `Escolha uma pasta existente (digite o número) ou deixe vazio para usar "${extractedName}":\n\n${playlistList}`
                        );
                        
                        if (choice && !isNaN(choice) && choice > 0 && choice <= existingPlaylists.length) {
                            finalPlaylistName = existingPlaylists[choice - 1];
                        } else {
                            finalPlaylistName = extractedName;
                        }
                    }
                }
                
                // Confirma o download
                const confirmDownload = confirm(
                    `Download será feito para a pasta: "${finalPlaylistName}"\n\n` +
                    `Clique em "OK" para continuar.`
                );
                
                if (!confirmDownload) {
                    return;
                }
                
                // Faz o download
                const resp = await fetch('http://localhost:5000/download_playlist', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        url, 
                        background: true,
                        playlist: finalPlaylistName
                    })
                });
                
                const data = await resp.json().catch(() => ({}));
                if (resp.status === 202) {
                    alert('Download iniciado em segundo plano. As músicas aparecerão na playlist ao finalizar.');
                } else if (!resp.ok || data.error) {
                    alert('Erro ao baixar: ' + (data.error || 'Erro desconhecido'));
                } else {
                    await updateMusicList();
                    alert('Download concluído: ' + (data.downloaded ? data.downloaded.length : 0) + ' arquivo(s).');
                }
            } catch (err) {
                console.error(err);
                alert('Falha ao comunicar com o servidor. Certifique-se de que o backend está rodando.');
            } finally {
                hideLoading(); // Hide loading animation
                importYtBtn.disabled = false;
            }
        });
        
        // Função para obter as playlists existentes
        async function getExistingPlaylists() {
            try {
                const resp = await fetch(`${API_BASE_URL}/list_playlists`);
                const data = await resp.json().catch(() => ({}));
                if (resp.ok && data.playlists) {
                    return data.playlists.map(p => p.name);
                }
                return [];
            } catch (err) {
                console.error('Erro ao obter playlists:', err);
                return [];
            }
        }

        // Botão de sincronização manual com a pasta musics
        const syncBtn = document.getElementById('syncBtn');
        if (syncBtn) {
            syncBtn.addEventListener('click', async function() {
                const originalHtml = syncBtn.innerHTML;
                try {
                    syncBtn.disabled = true;
                    syncBtn.innerHTML = '<span>⏳</span> Sincronizando...';
                    showLoading(); // Show loading animation
                    await updateMusicList();
                    alert('Sincronização concluída.');
                } catch (e) {
                    console.error('Erro ao sincronizar:', e);
                    alert('Erro ao sincronizar.');
                } finally {
                    hideLoading(); // Hide loading animation
                    syncBtn.disabled = false;
                    syncBtn.innerHTML = originalHtml;
                }
            });
        }
        
        // Botão para carregar todas as playlists com barra de progresso
        const loadAllBtn = document.getElementById('loadAllBtn');
        if (loadAllBtn) {
            loadAllBtn.addEventListener('click', function() {
                if (allPlaylists.length === 0) {
                    alert('Nenhuma playlist encontrada. Aguarde o carregamento inicial.');
                    return;
                }
                
                if (downloadProgress.isActive) {
                    alert('Carregamento já está em andamento. Aguarde a conclusão.');
                    return;
                }
                
                // Show loading animation
                showLoading();
                
                // Inicia o carregamento automático
                startAutoLoadAllPlaylists();
            });
        }

        // ===== CONTROLES DE VOLUME INDIVIDUAL =====
        
        // Variáveis para controle de volume
        let masterVolume = 100;
        let leftVolume = 100;
        let rightVolume = 100;
        let balance = 0;

        // Função para criar um AudioContext para controle de canais
        let audioContext;
        let gainNode;
        let splitter;
        let leftGain;
        let rightGain;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioContext.createGain();
                splitter = audioContext.createChannelSplitter(2);
                leftGain = audioContext.createGain();
                rightGain = audioContext.createGain();
                
                // Conecta os nós
                gainNode.connect(splitter);
                splitter.connect(leftGain, 0);
                splitter.connect(rightGain, 1);
                leftGain.connect(audioContext.destination, 0);
                rightGain.connect(audioContext.destination, 1);
            }
        }

        // Função para aplicar volume master
        function updateMasterVolume(value) {
            masterVolume = value;
            if (gainNode) {
                gainNode.gain.value = value / 100;
            }
            document.getElementById('masterVolumeValue').textContent = value + '%';
            
            // Atualiza os presets
            updateVolumePresetButtons();
        }

        // Função para aplicar volume do canal esquerdo
        function updateLeftVolume(value) {
            leftVolume = value;
            if (leftGain) {
                leftGain.gain.value = (value / 100) * (masterVolume / 100);
            }
            document.getElementById('leftVolumeValue').textContent = value + '%';
        }

        // Função para aplicar volume do canal direito
        function updateRightVolume(value) {
            rightVolume = value;
            if (rightGain) {
                rightGain.gain.value = (value / 100) * (masterVolume / 100);
            }
            document.getElementById('rightVolumeValue').textContent = value + '%';
        }

        // Função para aplicar balance
        function updateBalance(value) {
            balance = value;
            let balanceText = 'C';
            if (value < 0) {
                balanceText = 'D';
            } else if (value > 0) {
                balanceText = 'R';
            }
            document.getElementById('balanceValue').textContent = balanceText;
            
            // Aplica o balance nos canais
            if (leftGain && rightGain) {
                const leftFactor = value <= 0 ? 1 : Math.max(0, 1 - (value / 100));
                const rightFactor = value >= 0 ? 1 : Math.max(0, 1 + (value / 100));
                
                leftGain.gain.value = (leftVolume / 100) * (masterVolume / 100) * leftFactor;
                rightGain.gain.value = (rightVolume / 100) * (masterVolume / 100) * rightFactor;
            }
        }

        // Função para definir presets de volume
        function setVolumePreset(volume) {
            masterVolume = volume;
            leftVolume = volume;
            rightVolume = volume;
            balance = 0;
            
            // Atualiza os sliders
            document.getElementById('masterVolume').value = volume;
            document.getElementById('leftVolume').value = volume;
            document.getElementById('rightVolume').value = volume;
            document.getElementById('balanceSlider').value = 0;
            
            // Atualiza o controle simples também
            const simpleVolumeSlider = document.getElementById('simpleVolume');
            if (simpleVolumeSlider) {
                simpleVolumeSlider.value = volume;
            }
            
            // Aplica os volumes
            updateMasterVolume(volume);
            updateLeftVolume(volume);
            updateRightVolume(volume);
            updateBalance(0);
            
            // Atualiza os presets
            updateVolumePresetButtons();
        }

        // Função para atualizar os botões de preset
        function updateVolumePresetButtons() {
            const presetButtons = document.querySelectorAll('.volume-preset-btn');
            presetButtons.forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.textContent) === masterVolume) {
                    btn.classList.add('active');
                }
            });
        }

        // Função para aplicar volume ao áudio
        function applyVolumeToAudio() {
            if (!audioContext) {
                initAudioContext();
            }
            
            // Cria uma fonte de áudio a partir do elemento audio
            const audioElement = document.getElementById('playerAudio');
            if (audioElement && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Aplica os volumes atuais
            updateMasterVolume(masterVolume);
            updateLeftVolume(leftVolume);
            updateRightVolume(rightVolume);
            updateBalance(balance);
        }

        // Event listeners para os controles de volume
        document.addEventListener('DOMContentLoaded', function() {
            // Master Volume
            const masterSlider = document.getElementById('masterVolume');
            if (masterSlider) {
                masterSlider.addEventListener('input', function() {
                    updateMasterVolume(parseInt(this.value));
                });
            }

            // Left Channel Volume
            const leftSlider = document.getElementById('leftVolume');
            if (leftSlider) {
                leftSlider.addEventListener('input', function() {
                    updateLeftVolume(parseInt(this.value));
                });
            }

            // Right Channel Volume
            const rightSlider = document.getElementById('rightVolume');
            if (rightSlider) {
                rightSlider.addEventListener('input', function() {
                    updateRightVolume(parseInt(this.value));
                });
            }

            // Balance Slider
            const balanceSlider = document.getElementById('balanceSlider');
            if (balanceSlider) {
                balanceSlider.addEventListener('input', function() {
                    updateBalance(parseInt(this.value));
                });
            }

            // Inicializa o contexto de áudio quando o usuário interagir
            document.addEventListener('click', function() {
                if (!audioContext) {
                    initAudioContext();
                }
            }, { once: true });
        });

        // Função para testar os canais
        function testChannels() {
            if (!audioContext) {
                initAudioContext();
            }
            
            // Toca um tom de teste em cada canal
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        // Adiciona botão de teste (opcional)
        function addTestButton() {
            const testBtn = document.createElement('button');
            testBtn.className = 'volume-preset-btn';
            testBtn.textContent = 'Test';
            testBtn.onclick = testChannels;
            testBtn.style.marginTop = '8px';
            
            const presetsContainer = document.querySelector('.volume-presets');
            if (presetsContainer) {
                presetsContainer.appendChild(testBtn);
            }
        }

        // Inicializa os controles quando a página carregar
        window.addEventListener('load', function() {
            addTestButton();
            updateVolumePresetButtons();
        });

        // ===== CONTROLE DE VISIBILIDADE DOS CONTROLES DE VOLUME =====
        
        let volumeControlsVisible = localStorage.getItem('volumeControlsVisible') !== 'false';
        
        // Se não há estado salvo, define como visível por padrão
        if (localStorage.getItem('volumeControlsVisible') === null) {
            localStorage.setItem('volumeControlsVisible', 'true');
        }

        // Função para alternar a visibilidade dos controles de volume
        function toggleVolumeControls() {
            const volumeContainer = document.querySelector('.volume-container');
            const toggleBtn = document.getElementById('volumeToggleBtn');
            const toggleBtnSimple = document.getElementById('volumeToggleBtnSimple');
            
            // Verifica se os elementos existem
            if (!volumeContainer || !toggleBtn || !toggleBtnSimple) {
                console.warn('Elementos de controle de volume não encontrados');
                return;
            }
            
            volumeControlsVisible = !volumeControlsVisible;
            
            if (volumeControlsVisible) {
                // Mostra os controles avançados
                if (volumeContainer) {
                    volumeContainer.classList.remove('hidden');
                }
                
                if (toggleBtn) {
                    toggleBtn.classList.remove('hidden');
                    const toggleIcon = toggleBtn.querySelector('.toggle-icon');
                    if (toggleIcon) {
                        toggleIcon.textContent = 'settings';
                    }
                    toggleBtn.title = 'Esconder Controles de Volume';
                }
                
                // Atualiza o botão simples
                if (toggleBtnSimple) {
                    const toggleIconSimple = toggleBtnSimple.querySelector('.toggle-icon');
                    if (toggleIconSimple) {
                        toggleIconSimple.textContent = 'settings';
                    }
                    toggleBtnSimple.title = 'Esconder Controles de Volume';
                }
                
                // Salva o estado no localStorage
                localStorage.setItem('volumeControlsVisible', 'true');
            } else {
                // Esconde os controles avançados (mostra o simples)
                if (volumeContainer) {
                    volumeContainer.classList.add('hidden');
                }
                
                if (toggleBtn) {
                    toggleBtn.classList.add('hidden');
                    const toggleIcon = toggleBtn.querySelector('.toggle-icon');
                    if (toggleIcon) {
                        toggleIcon.textContent = 'tune';
                    }
                    toggleBtn.title = 'Mostrar Controles de Volume';
                }
                
                // Atualiza o botão simples
                if (toggleBtnSimple) {
                    const toggleIconSimple = toggleBtnSimple.querySelector('.toggle-icon');
                    if (toggleIconSimple) {
                        toggleIconSimple.textContent = 'tune';
                    }
                    toggleBtnSimple.title = 'Mostrar Controles de Volume';
                }
                
                // Salva o estado no localStorage
                localStorage.setItem('volumeControlsVisible', 'false');
            }
        }

        // Função para restaurar o estado dos controles de volume
        function restoreVolumeControlsState() {
            const volumeContainer = document.querySelector('.volume-container');
            const toggleBtn = document.getElementById('volumeToggleBtn');
            const toggleBtnSimple = document.getElementById('volumeToggleBtnSimple');
            
            // Verifica se os elementos existem
            if (!volumeContainer || !toggleBtn || !toggleBtnSimple) {
                console.warn('Elementos de controle de volume não encontrados na restauração');
                return;
            }
            
            if (!volumeControlsVisible) {
                // Se deve estar escondido
                if (volumeContainer) {
                    volumeContainer.classList.add('hidden');
                }
                
                if (toggleBtn) {
                    toggleBtn.classList.add('hidden');
                    const toggleIcon = toggleBtn.querySelector('.toggle-icon');
                    if (toggleIcon) {
                        toggleIcon.textContent = 'tune';
                    }
                    toggleBtn.title = 'Mostrar Controles de Volume';
                }
                
                if (toggleBtnSimple) {
                    const toggleIconSimple = toggleBtnSimple.querySelector('.toggle-icon');
                    if (toggleIconSimple) {
                        toggleIconSimple.textContent = 'tune';
                    }
                    toggleBtnSimple.title = 'Mostrar Controles de Volume';
                }
            } else {
                // Se deve estar visível
                if (volumeContainer) {
                    volumeContainer.classList.remove('hidden');
                }
                
                if (toggleBtn) {
                    toggleBtn.classList.remove('hidden');
                    const toggleIcon = toggleBtn.querySelector('.toggle-icon');
                    if (toggleIcon) {
                        toggleIcon.textContent = 'settings';
                    }
                    toggleBtn.title = 'Esconder Controles de Volume';
                }
                
                if (toggleBtnSimple) {
                    const toggleIconSimple = toggleBtnSimple.querySelector('.toggle-icon');
                    if (toggleIconSimple) {
                        toggleIconSimple.textContent = 'settings';
                    }
                    toggleBtnSimple.title = 'Esconder Controles de Volume';
                }
            }
        }

        // Função para sincronizar volume simples com volume master
        function syncSimpleVolume() {
            const simpleVolumeSlider = document.getElementById('simpleVolume');
            const simpleVolumeValue = document.getElementById('simpleVolumeValue');
            const masterVolumeSlider = document.getElementById('masterVolume');
            
            if (simpleVolumeSlider && masterVolumeSlider && simpleVolumeValue) {
                const masterValue = masterVolumeSlider.value;
                simpleVolumeSlider.value = masterValue;
                simpleVolumeValue.textContent = masterValue + '%';
            } else {
                console.warn('Elementos de volume não encontrados para sincronização');
            }
        }

        // Função para aplicar volume simples
        function updateSimpleVolume(value) {
            // Atualiza o volume master também
            if (typeof updateMasterVolume === 'function') {
                updateMasterVolume(value);
            }
            
            // Atualiza o slider e valor do controle simples
            const simpleVolumeSlider = document.getElementById('simpleVolume');
            const simpleVolumeValue = document.getElementById('simpleVolumeValue');
            
            if (simpleVolumeSlider && simpleVolumeValue) {
                simpleVolumeSlider.value = value;
                simpleVolumeValue.textContent = value + '%';
            } else {
                console.warn('Elementos de volume simples não encontrados');
            }
        }

        // Event listener para o botão toggle
        document.addEventListener('DOMContentLoaded', function() {
            const toggleBtn = document.getElementById('volumeToggleBtn');
            const toggleBtnSimple = document.getElementById('volumeToggleBtnSimple');
            
            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleVolumeControls);
            } else {
                console.warn('Botão de toggle de volume não encontrado');
            }
            
            if (toggleBtnSimple) {
                toggleBtnSimple.addEventListener('click', toggleVolumeControls);
            } else {
                console.warn('Botão de toggle de volume simples não encontrado');
            }
            
            // Event listeners para os controles de volume
            const masterVolumeSlider = document.getElementById('masterVolume');
            const leftVolumeSlider = document.getElementById('leftVolume');
            const rightVolumeSlider = document.getElementById('rightVolume');
            const balanceSlider = document.getElementById('balanceSlider');
            const simpleVolumeSlider = document.getElementById('simpleVolume');
            
            if (masterVolumeSlider) {
                masterVolumeSlider.addEventListener('input', function() {
                    updateMasterVolume(parseInt(this.value));
                });
            } else {
                console.warn('Slider de volume master não encontrado');
            }
            
            if (leftVolumeSlider) {
                leftVolumeSlider.addEventListener('input', function() {
                    updateLeftVolume(parseInt(this.value));
                });
            } else {
                console.warn('Slider de volume esquerdo não encontrado');
            }
            
            if (rightVolumeSlider) {
                rightVolumeSlider.addEventListener('input', function() {
                    updateRightVolume(parseInt(this.value));
                });
            } else {
                console.warn('Slider de volume direito não encontrado');
            }
            
            if (balanceSlider) {
                balanceSlider.addEventListener('input', function() {
                    updateBalance(parseInt(this.value));
                });
            } else {
                console.warn('Slider de balance não encontrado');
            }
            
            if (simpleVolumeSlider) {
                simpleVolumeSlider.addEventListener('input', function() {
                    updateSimpleVolume(parseInt(this.value));
                });
            } else {
                console.warn('Slider de volume simples não encontrado');
            }
            
            // Restaura o estado salvo
            restoreVolumeControlsState();
            
            // Sincroniza o volume simples com o master
            syncSimpleVolume();
            
            // Log do estado inicial para debug
            console.log('Estado inicial dos controles de volume:', volumeControlsVisible ? 'visível' : 'escondido');
        });

        // Atalho de teclado para mostrar/esconder controles (Ctrl + V)
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'v') {
                e.preventDefault();
                toggleVolumeControls();
            }
        });

        // ===== FUNÇÕES DE GERENCIAMENTO DE PLAYLISTS =====

        let currentPlaylist = '';
        let allPlaylists = [];

        // Função para carregar a lista de playlists
        async function loadPlaylists() {
            try {
                console.log('🔄 [PRIORIDADE 2] Carregando lista de playlists...');
                const response = await fetch(`${API_BASE_URL}/list_playlists`);
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                allPlaylists = data.playlists;
                updatePlaylistsList();
                updatePlaylistSelector();
                
                // Prepara a barra de progresso se houver playlists (não mostra automaticamente)
                if (allPlaylists.length > 0) {
                    // Inicializa sem mostrar
                    downloadProgress.totalPlaylists = allPlaylists.length;
                    downloadProgress.processedPlaylists = 0;
                    downloadProgress.totalFiles = 0;
                    downloadProgress.processedFiles = 0;
                    downloadProgress.playlists.clear();
                    
                    // Inicializa o progresso de cada playlist
                    allPlaylists.forEach(playlist => {
                        downloadProgress.playlists.set(playlist.name, {
                            name: playlist.name,
                            status: 'pending',
                            progress: 0,
                            totalFiles: playlist.music_count || 0,
                            processedFiles: 0,
                            error: null
                        });
                        downloadProgress.totalFiles += playlist.music_count || 0;
                    });
                }
                
                console.log(`✅ [PRIORIDADE 2] Carregadas ${allPlaylists.length} playlists`);
            } catch (error) {
                console.error('❌ [PRIORIDADE 2] Erro ao carregar playlists:', error);
            }
        }

        // Função para atualizar a lista de playlists na interface
        function updatePlaylistsList() {
            const playlistsList = document.getElementById('playlistsList');
            if (!playlistsList) {
                console.error('❌ Elemento playlistsList não encontrado!');
                return;
            }

            console.log('🔄 Atualizando lista de playlists:', allPlaylists);
            playlistsList.innerHTML = '';

            if (allPlaylists.length === 0) {
                playlistsList.innerHTML = '<div style="text-align:center;color:#666;padding:20px;">Nenhuma playlist encontrada</div>';
                return;
            }

            allPlaylists.forEach(playlist => {
                const playlistCard = document.createElement('div');
                const isActive = playlist.name === currentPlaylist;
                playlistCard.className = `playlist-card ${isActive ? 'active' : ''}`;
                playlistCard.onclick = () => loadPlaylist(playlist.name);
                
                const coverUrl = resolveCoverUrl(playlist.cover || 'musics/default-cover.jpg');
                console.log(`📸 Cover URL para ${playlist.name}:`, coverUrl);
                
                playlistCard.innerHTML = `
                    <div class="playlist-cover-container">
                        <img class="playlist-cover" src="${coverUrl}" alt="${playlist.name}" style="width:100%;height:100%;object-fit:cover;display:block;transition:all 0.3s ease;" onerror="console.error('Erro ao carregar imagem:', this.src); this.src='${resolveCoverUrl('musics/default-cover.jpg')}'">
                        ${isActive ? '<div style="position:absolute;top:4px;right:4px;background:rgba(29,185,84,0.9);color:white;border-radius:50%;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:bold;">▶</div>' : ''}
                    </div>
                    <h4>
                        <div class="playlist-title-with-cover">
                            <span>${playlist.name}</span>
                        </div>
                    </h4>
                    <div class="music-count">${playlist.music_count} música${playlist.music_count !== 1 ? 's' : ''}</div>
                `;
                
                playlistsList.appendChild(playlistCard);
            });
        }

        // Função para atualizar o seletor de playlists
        function updatePlaylistSelector() {
            const playlistSelector = document.getElementById('playlistSelector');
            if (!playlistSelector) return;

            // Mantém a opção "Todas as músicas"
            playlistSelector.innerHTML = '<option value="">Todas as músicas</option>';

            allPlaylists.forEach(playlist => {
                const option = document.createElement('option');
                option.value = playlist.name;
                option.textContent = `${playlist.name} (${playlist.music_count})`;
                playlistSelector.appendChild(option);
            });
        }

        // Função para carregar uma playlist específica
        async function loadPlaylist(playlistName) {
            console.log(`🔄 [PRIORIDADE 4] Carregando playlist: ${playlistName || 'Todas as músicas'}`);
            currentPlaylist = playlistName;
            
            // Atualiza o título da playlist atual
            const currentPlaylistTitle = document.getElementById('currentPlaylistTitle');
            if (currentPlaylistTitle) {
                currentPlaylistTitle.textContent = playlistName || 'Todas as músicas';
            }

            // Atualiza a interface das playlists para destacar a ativa
            updatePlaylistsList();

            // Se for uma playlist específica, atualiza o progresso
            if (playlistName && downloadProgress.isActive) {
                updatePlaylistProgress(playlistName, 0, 'processing');
            }

            // Carrega as músicas da playlist
            try {
                const url = playlistName 
                    ? `http://localhost:5000/list_music?playlist=${encodeURIComponent(playlistName)}`
                    : 'http://localhost:5000/list_music';
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                // Processa as músicas da playlist
                await processPlaylistMusic(data.music, playlistName);
                console.log(`✅ [PRIORIDADE 4] Playlist carregada: ${playlistName || 'Todas as músicas'}`);
                
                // Marca como concluída se estiver usando a barra de progresso
                if (playlistName && downloadProgress.isActive) {
                    completePlaylist(playlistName);
                }
                
            } catch (error) {
                console.error('❌ [PRIORIDADE 4] Erro ao carregar playlist:', error);
                
                // Marca como erro se estiver usando a barra de progresso
                if (playlistName && downloadProgress.isActive) {
                    errorPlaylist(playlistName, error.message);
                }
            }
        }

        // Função otimizada para processar músicas de uma playlist
        async function processPlaylistMusic(musicList, playlistName = null) {
            // Limpa a playlist atual
            playlist.length = 0;
            
            // Mostra indicador de carregamento
            const playlistContainer = document.querySelector('.playlist-container');
            if (playlistContainer) {
                playlistContainer.innerHTML = '<div class="loading-indicator">Carregando músicas...</div>';
            }
            
            const batchSize = 10; // Processa 10 músicas por vez
            const totalMusic = musicList.length;
            let processedCount = 0;
            
            for (let i = 0; i < musicList.length; i += batchSize) {
                const batch = musicList.slice(i, i + batchSize);
                const promises = batch.map(music => processSingleMusicFile(music));
                
                // Processa o lote em paralelo
                const results = await Promise.allSettled(promises);
                
                // Atualiza contador de progresso
                processedCount += batch.length;
                
                // Atualiza indicador de carregamento local
                if (playlistContainer) {
                    playlistContainer.innerHTML = `<div class="loading-indicator">Carregando músicas... ${processedCount}/${totalMusic}</div>`;
                }
                
                // Atualiza barra de progresso se estiver ativa
                if (playlistName && downloadProgress.isActive) {
                    updatePlaylistFileProgress(playlistName, processedCount);
                }
                
                // Pequena pausa entre lotes para não travar a interface
                if (i + batchSize < musicList.length) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }
            
            // Finaliza o carregamento
            await dedupePlaylistAndDB();
            sortPlaylist();
            updatePlaylistHTML();
            updateDurations();
        }
        
        // Função para processar uma única música
        async function processSingleMusicFile(music) {
            try {
                // Verifica se já existe no IndexedDB
                const existing = await getMusicByFileName(music.name);
                if (existing) {
                    try {
                        const url = arrayBufferToBlobUrl(existing.file, existing.fileType);
                        playlist.push({ ...existing, file: url });
                        return;
                    } catch (e) {
                        console.error('Erro ao criar URL para música existente:', e);
                        // Remove a música corrompida do DB e baixa novamente
                        await deleteMusicFromDB(existing.id);
                    }
                }

                // Infere metadados básicos a partir do nome do arquivo quando ausentes
                let inferredTitle = 'Desconhecido';
                let inferredArtist = 'Desconhecido';
                try {
                    const base = (music.name || '').replace(/\.[^.]+$/, '');
                    if (base.includes(' - ')) {
                        const parts = base.split(' - ');
                        if (parts.length >= 2) {
                            inferredArtist = (parts[0] || '').trim() || inferredArtist;
                            inferredTitle = (parts.slice(1).join(' - ') || '').trim() || inferredTitle;
                        }
                    } else {
                        inferredTitle = base || inferredTitle;
                    }
                } catch (e) { /* noop */ }

                // Baixa o arquivo e salva no IndexedDB
                const response = await fetch(`http://localhost:5000${music.path}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                
                // Verifica se o arrayBuffer não está vazio
                if (arrayBuffer.byteLength === 0) {
                    throw new Error('Arquivo vazio recebido do servidor');
                }
                
                const musicRecord = {
                    title: (music.title && music.title.trim()) || inferredTitle,
                    artist: (music.artist && music.artist.trim()) || inferredArtist,
                    album: (music.album && music.album.trim()) || 'Desconhecido',
                    duration: "0:00",
                    cover: music.cover || 'musics/default-cover.jpg',
                    file: arrayBuffer,
                    fileType: getMimeType(music.name),
                    fileName: music.name,
                    trackNumber: playlist.length + 1,
                    playlist: music.playlist || 'Geral'
                };

                const id = await saveMusicToDB(musicRecord);
                musicRecord.id = id;

                try {
                    const blobUrl = arrayBufferToBlobUrl(arrayBuffer, musicRecord.fileType);
                    playlist.push({ ...musicRecord, file: blobUrl });
                } catch (e) {
                    console.error('Erro ao criar blob URL para:', music.name, e);
                    // Remove do DB se não conseguir criar o blob
                    await deleteMusicFromDB(id);
                }
            } catch (e) {
                console.error('Falha ao processar música da playlist:', music.name, e);
            }
        }

        // Função para criar uma nova playlist
        async function createPlaylist(name) {
            try {
                const response = await fetch('http://localhost:5000/create_playlist', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }

                // Recarrega a lista de playlists
                await loadPlaylists();
                
                return data;
            } catch (error) {
                console.error('Erro ao criar playlist:', error);
                throw error;
            }
        }

        // Função para mostrar modal de criação de playlist
        function showCreatePlaylistModal() {
            const name = prompt('Digite o nome da nova playlist:');
            if (name && name.trim()) {
                createPlaylist(name.trim())
                    .then(() => alert('Playlist criada com sucesso!'))
                    .catch(error => alert('Erro ao criar playlist: ' + error.message));
            }
        }

        // Função para mostrar modal de upload para playlist
        function showUploadModal() {
            const playlistSelector = document.getElementById('playlistSelector');
            const currentPlaylistName = currentPlaylist || 'Geral';
            
            const playlistName = prompt(
                `Digite o nome da playlist para upload (atual: ${currentPlaylistName}):`,
                currentPlaylistName
            );
            
            if (playlistName) {
                // Atualiza o input de arquivo para incluir a playlist
                const fileInput = document.getElementById('fileInput');
                fileInput.setAttribute('data-playlist', playlistName);
                fileInput.click();
            }
        }

        // Função para obter MIME type baseado na extensão
        function getMimeType(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const mimeTypes = {
                'mp3': 'audio/mpeg',
                'm4a': 'audio/mp4',
                'aac': 'audio/aac',
                'ogg': 'audio/ogg',
                'opus': 'audio/opus',
                'wav': 'audio/wav',
                'flac': 'audio/flac',
                'webm': 'audio/webm'
            };
            return mimeTypes[ext] || 'audio/mpeg';
        }

        // Modifica a função handleFileUpload para suportar playlists
        const originalHandleFileUpload = handleFileUpload;
        handleFileUpload = async function(event) {
            const files = event.target.files;
            if (!files.length) return;

            const playlistName = event.target.getAttribute('data-playlist') || 'Geral';
            
            for (const file of files) {
                console.log('Processando arquivo:', file.name, file.type, file.size);
                
                if (!file.type.startsWith('audio/')) {
                    console.warn('Arquivo não é de áudio:', file.name, file.type);
                    continue;
                }

                // Valida o arquivo antes de processar
                validateAudioFile(file);

                try {
                    // Lê os metadados ID3
                    let title = "";
                    let artist = "";
                    let album = "";
                    let cover = "";

                    await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const arrayBuffer = e.target.result;
                            const blob = new Blob([arrayBuffer], { type: file.type });
                            
                            // Tenta extrair metadados usando jsmediatags
                            if (typeof jsmediatags !== 'undefined') {
                                jsmediatags.read(blob, {
                                    onSuccess: function(tag) {
                                        title = tag.tags.title || "";
                                        artist = tag.tags.artist || "";
                                        album = tag.tags.album || "";
                                        resolve();
                                    },
                                    onError: function(error) {
                                        console.log('Erro ao ler metadados:', error);
                                        resolve();
                                    }
                                });
                            } else {
                                resolve();
                            }
                        };
                        reader.readAsArrayBuffer(file);
                    });

                    // Se não conseguiu extrair metadados, tenta buscar no Deezer
                    if (!title || !artist) {
                        cover = await fetchDeezerCover(title, artist);
                    }

                    // Cria o objeto da música
                    const arrayBuffer = await file.arrayBuffer();
                    console.log('ArrayBuffer criado, tamanho:', arrayBuffer.byteLength);
                    
                    const music = {
                        title: title || "Desconhecido",
                        artist: artist || "Desconhecido",
                        album: album || "Desconhecido",
                        duration: "0:00",
                        cover: cover,
                        file: arrayBuffer,
                        fileType: file.type,
                        fileName: file.name,
                        trackNumber: playlist.length + 1,
                        playlist: playlistName
                    };

                    // Salva no banco de dados
                    const id = await saveMusicToDB(music);
                    music.id = id;

                    // Cria URL do blob para reprodução
                    try {
                        const blob = new Blob([arrayBuffer], { type: file.type });
                        music.file = URL.createObjectURL(blob);
                        console.log('Blob URL criado para upload:', music.file);
                    } catch (blobError) {
                        console.error('Erro ao criar blob URL:', blobError);
                        throw new Error('Falha ao processar o arquivo de áudio');
                    }

                    // Adiciona à playlist
                    playlist.push(music);

                    // Atualiza a duração
                    const audio = new Audio(music.file);
                    audio.addEventListener('loadedmetadata', () => {
                        const minutes = Math.floor(audio.duration / 60);
                        const seconds = Math.floor(audio.duration % 60);
                        music.duration = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        sortPlaylist();
                        updatePlaylistHTML();
                    });

                    audio.addEventListener('error', (e) => {
                        console.error('Erro ao carregar áudio do upload:', e);
                        console.error('Detalhes do erro:', audio.error);
                    });

                    if (playlist.length === 1) {
                        currentTrack = 0;
                        loadTrack();
                    }
                } catch (error) {
                    console.error('Erro ao processar arquivo:', error);
                    alert(`Erro ao processar o arquivo ${file.name}: ${error.message}`);
                }
            }

            event.target.value = '';
            event.target.removeAttribute('data-playlist');
        };

        // Modifica a função updateMusicList para suportar playlists
        const originalUpdateMusicList = updateMusicList;
        updateMusicList = async function() {
            try {
                console.log('Atualizando lista de músicas...');
                
                // Recarrega a lista de playlists primeiro
                await loadPlaylists();
                
                const url = currentPlaylist 
                    ? `http://localhost:5000/list_music?playlist=${encodeURIComponent(currentPlaylist)}`
                    : 'http://localhost:5000/list_music';
                
                const response = await fetch(url);
                console.log('Resposta do servidor:', response.status);
                
                const data = await response.json();
                console.log('Dados recebidos:', data);
                
                if (data.error) {
                    throw new Error(data.error);
                }

                // Conjunto de nomes de arquivo já presentes na playlist (via DB ou remoto)
                const playlistFileNames = new Set(
                    playlist
                        .map(track => track.fileName || (typeof track.file === 'string' ? track.file.split('/').pop().split('?')[0] : undefined))
                        .filter(Boolean)
                );

                // Filtra somente músicas novas por nome do arquivo
                const newMusic = data.music.filter(music => !playlistFileNames.has(music.name));

                if (newMusic.length > 0) {
                    console.log('Novas músicas encontradas:', newMusic);

                    for (const music of newMusic) {
                        try {
                            // Verifica se já existe no IndexedDB
                            const existing = await getMusicByFileName(music.name);
                            if (existing) {
                                // Atualiza metadados se estiverem desconhecidos e o backend trouxe dados
                                const isUnknown = (v) => !v || /desconhecid/i.test(String(v));
                                const updated = { ...existing };
                                let changed = false;
                                if (music.title && (isUnknown(existing.title))) { updated.title = music.title; changed = true; }
                                if (music.artist && (isUnknown(existing.artist))) { updated.artist = music.artist; changed = true; }
                                if (music.album && (isUnknown(existing.album))) { updated.album = music.album; changed = true; }
                                if (music.year && isUnknown(existing.year)) { updated.year = String(music.year); changed = true; }
                                if (music.cover && (isUnknown(existing.cover) || /default-cover\.jpg$/.test(existing.cover || ''))) { updated.cover = music.cover; changed = true; }
                                if (changed) {
                                    try { await updateMusicInDB(updated); } catch (e) { console.error('Falha ao atualizar DB:', e); }
                                }
                                const url = arrayBufferToBlobUrl(updated.file, updated.fileType);
                                playlist.push({ ...updated, file: url });
                                continue;
                            }

                            // Baixa o arquivo do servidor e salva no IndexedDB
                            const musicResponse = await fetch(`http://localhost:5000${music.path}`);
                            const arrayBuffer = await musicResponse.arrayBuffer();
                            
                            // Determina o MIME type baseado na extensão
                            const mimeType = getMimeType(music.name);
                            
                            // Tenta extrair metadados do arquivo
                            let title = music.title || '';
                            let artist = music.artist || '';
                            let album = music.album || '';
                            let coverUrl = music.cover || 'musics/default-cover.jpg';
                            
                            // Se não tem metadados, tenta buscar no Deezer
                            if (!title || !artist) {
                                try {
                                    const enriched = await _enrich_metadata_from_deezer(title, artist);
                                    title = enriched.get('title') || title;
                                    artist = enriched.get('artist') || artist;
                                    album = enriched.get('album') || album;
                                    coverUrl = enriched.get('cover') || coverUrl;
                                } catch {}
                            }

                            const musicRecord = {
                                title: title,
                                artist: artist,
                                album: album,
                                duration: "0:00",
                                cover: coverUrl,
                                file: arrayBuffer,
                                fileType: mimeType,
                                fileName: music.name,
                                trackNumber: playlist.length + 1,
                                year: (music.year && String(music.year)) || '',
                                playlist: music.playlist || 'Geral'
                            };

                            const id = await saveMusicToDB(musicRecord);
                            musicRecord.id = id;

                            const blobUrl = arrayBufferToBlobUrl(arrayBuffer, mimeType);
                            playlist.push({ ...musicRecord, file: blobUrl });
                        } catch (e) {
                            console.error('Falha ao processar música nova:', music, e);
                        }
                    }

                    await dedupePlaylistAndDB();
                    sortPlaylist();
                    updatePlaylistHTML();
                    updateDurations();
                }
            } catch (error) {
                console.error('Erro ao atualizar lista de músicas:', error);
                if (error.message && error.message.includes('Failed to fetch')) {
                    console.error('Não foi possível conectar ao servidor. Verifique se o servidor está rodando.');
                }
            }
        };





        // Mostra controles temporariamente quando o volume é alterado
        function showControlsOnVolumeChange() {
            if (!volumeControlsVisible) {
                // Não mostra temporariamente, apenas atualiza o controle simples
                setTimeout(syncSimpleVolume, 100);
            }
        }

        // Atualiza as funções de volume para mostrar controles quando alterados
        const originalUpdateMasterVolume = typeof updateMasterVolume === 'function' ? updateMasterVolume : function(){};
        const originalUpdateLeftVolume = typeof updateLeftVolume === 'function' ? updateLeftVolume : function(){};
        const originalUpdateRightVolume = typeof updateRightVolume === 'function' ? updateRightVolume : function(){};
        const originalUpdateBalance = typeof updateBalance === 'function' ? updateBalance : function(){};

        // Sobrescreve as funções para incluir a funcionalidade de mostrar controles
        window.updateMasterVolume = function(value) {
            if (originalUpdateMasterVolume) {
                originalUpdateMasterVolume(value);
            }
            showControlsOnVolumeChange();
        };

        window.updateLeftVolume = function(value) {
            if (originalUpdateLeftVolume) {
                originalUpdateLeftVolume(value);
            }
            showControlsOnVolumeChange();
        };

        window.updateRightVolume = function(value) {
            if (originalUpdateRightVolume) {
                originalUpdateRightVolume(value);
            }
            showControlsOnVolumeChange();
        };

        window.updateBalance = function(value) {
            if (originalUpdateBalance) {
                originalUpdateBalance(value);
            }
            showControlsOnVolumeChange();
        };

        // Função para limpar URLs de blob antigas
        function cleanupBlobUrls() {
            // Limpa URLs de blob que não estão mais sendo usadas
            const usedUrls = new Set();
            playlist.forEach(track => {
                if (track.file && track.file.startsWith('blob:')) {
                    usedUrls.add(track.file);
                }
            });
            
            // Aqui você poderia implementar um sistema para rastrear e limpar URLs não utilizadas
            // Por enquanto, apenas logamos as URLs em uso
            console.log('URLs de blob em uso:', usedUrls.size);
        }

        // Função para recarregar uma música específica
        async function reloadTrack(trackIndex) {
            if (trackIndex < 0 || trackIndex >= playlist.length) {
                console.error('Índice de faixa inválido:', trackIndex);
                return;
            }
            
            const track = playlist[trackIndex];
            console.log('Recarregando faixa:', track.title);
            
            try {
                // Se a faixa tem fileArrayBuffer, recria o blob URL
                if (track.fileArrayBuffer && !track.file) {
                    const blob = new Blob([track.fileArrayBuffer], { 
                        type: track.fileType || 'audio/mpeg' 
                    });
                    track.file = URL.createObjectURL(blob);
                    console.log('Blob URL recriado para:', track.title);
                }
                
                // Se é a faixa atual, recarrega
                if (trackIndex === currentTrack) {
                    loadTrack();
                }
            } catch (error) {
                console.error('Erro ao recarregar faixa:', error);
            }
        }

        // Função para debug da playlist
        function debugPlaylist() {
            console.log('=== DEBUG DA PLAYLIST ===');
            console.log('Playlist atual:', playlist);
            console.log('Faixa atual:', currentTrack);
            console.log('Reproduzindo:', isPlaying);
            console.log('Elemento de áudio:', audio);
            console.log('Src do áudio:', audio.src);
            console.log('Ready state:', audio.readyState);
            console.log('Network state:', audio.networkState);
            console.log('Erro do áudio:', audio.error);
            
            if (playlist.length > 0) {
                console.log('=== DETALHES DA FAIXA ATUAL ===');
                const currentTrackData = playlist[currentTrack];
                console.log('Faixa atual:', currentTrackData);
                console.log('Tem arquivo:', !!currentTrackData.file);
                console.log('Tem fileArrayBuffer:', !!currentTrackData.fileArrayBuffer);
                console.log('Tipo do arquivo:', currentTrackData.fileType);
                console.log('Nome do arquivo:', currentTrackData.fileName);
                
                if (currentTrackData.file) {
                    console.log('URL do arquivo:', currentTrackData.file);
                    console.log('É blob URL:', currentTrackData.file.startsWith('blob:'));
                }
            }
            
            // Testa a reprodução da faixa atual
            if (playlist.length > 0) {
                console.log('=== TESTE DE REPRODUÇÃO ===');
                const testAudio = new Audio();
                const track = playlist[currentTrack];
                
                if (track.file) {
                    testAudio.src = track.file;
                    testAudio.load();
                    
                    testAudio.addEventListener('canplaythrough', () => {
                        console.log('✅ Teste de reprodução: SUCESSO');
                        testAudio.src = '';
                    });
                    
                    testAudio.addEventListener('error', (e) => {
                        console.error('❌ Teste de reprodução: FALHOU');
                        console.error('Erro:', testAudio.error);
                        testAudio.src = '';
                    });
                    
                    // Timeout de 5 segundos
                    setTimeout(() => {
                        if (testAudio.src) {
                            console.log('⏰ Teste de reprodução: TIMEOUT');
                            testAudio.src = '';
                        }
                    }, 5000);
                } else {
                    console.log('❌ Nenhum arquivo para testar');
                }
            }
            
            alert('Verifique o console para detalhes do debug');
        }
    </script>
</body>
</html> 
